# 应用系统体系架构汇总

# Architecture 架构

- 应用服务器和数据库服务器分开：数据库服务器架在内网 外网连不到
  - 性能：
  - 安全：数据库不能用应用ip访问
- 分布式缓存服务器
  - 读盘慢
  - 注意经常变化的不要放到缓存里，保证一致性
- 负载均衡服务器：调度多个应用服务器
  - 可能要求同一个session调用同一个服务器（nginx中的ip hash）
- 数据库主从备份
  - 写主 同步从；读 主从均可 负载均衡
  - 可能切换主从角色，防止过热过冷
- CDN内容分发网络
  - 内容放到全国各地，访问的时候距离最近
  - 反向代理服务器：访问的时候 反向代理服务器去管具体访问哪个节点
- 统一数据访问网关
  - 抽离先缓存，后数据库等，访问数据统一走数据访问网关
- 多数据库
  - 数据放在最适合的地方，数据访问网关统一管理
- 消息服务器
  - 异步通信
- 微服务
  - 公共服务复用

一个完整的企业级应用架构图如下：

![1736606977636](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736606977636.jpg)



# 实例

### 实例池，对象**池**

- **管理和重用对象实例：**对象池通常是一个集合，用于存储和管理多个对象实例。当需要使用对象时，可以从对象池中获取一个可用的对象，而不是每次都创建新的对象。一旦使用完成，可以将对象返回到对象池中，以便稍后重用，而不是立即销毁它。
- 有一定的大小：防止1000条访问内存爆炸
- 一定的内存大小服务多个用户：
  - 如果只能写两个，共有ABC三个状态
  - 写入A，B后，C也要进入
  - 就把A序列化成字符串后把C swap in，把A swap out到磁盘上
  - swap in/out的根据是LRU
  - 有状态的因为swap in/out太多，所以效率低还占据空间，所以最好写无状态代码



### HTTP状态

#### Http是无状态协议：

每次HTTP请求都是独立的，服务器不会自动记住前后请求之间的关系。每个请求在服务器看来是一个完全独立的事务，与之前的请求无关。（如果你发出多个请求，服务器不会跟踪这些请求之间的顺序或关系）



#### **HTTP有状态服务：**

1. Session：存储在服务器端，服务器为每个用户会话生成一个唯一的Session ID，用键值对存储信息（信息可以比较复杂）
   - 某一个用户的购物车对象等信息
2. Cookie：存储在客户端（浏览器），安全性低
   - cookie对应的是每个对象的id
3. Token：存储在客户端（浏览器的LocalStorage、SessionStorage或Cookie中），包含了用户的身份和权限信息，服务器不需要保存Token状态。加密数据片段，通常用于身份验证。Token 常见的形式是JWT（JSON Web Token）

有状态**消耗额外的（内存）资源**



#### 无状态服务

- 上一次调用跟这次没关系，尽量无状态
- 只要一个对象都行



### Scope

- Singleton（单例模式） : Stateless

  - 默认，整个bean里只有一个对象
- Prototype : Stateful

  - 每次**调用(所有的Bean)**产生一个新对象
  - 所以两次访问会产生两个controller（如果controller为prototype）
- request 专用于web应用

  - 每次http请求就产生一个新对象
- session 专用于web应用

  - 一个客户端调用两次，使用的是一个对象

  - 两个客户端各调用一次，使用的是两个对象（会属于不同的session）
- application 专用于web应用

  - 整个bean只有一个对象



#### 应该如何设计scopes of Beans

- 如果不同用户看到的内容一样，使用singleton即可
  - 比如主页的所有书籍的具体信息
- 如果不同用户看到的内容不一样，即需要为每个用户维护一个状态，就可以用prototype
  - 让每个用户维护它在线多长时间了
    - 这个东西就可能需要做一个session和prototype的组合

------



#### 连接池

- 连接本质是线程，线程切换有代价

- 数据库连接池和实际能够承受的连接数的关系：

  connections =((core_count * 2) + effective_spindle_count(有效硬盘数量))

  - 数据库的最终实现是读硬盘，但是在读的时候线程是废的，所以还要加上有效的硬盘数量
  - 这个硬盘数量指的是数据库硬盘的数量，而不是后端服务器硬盘的数量

- 读盘过程线程是空的，可以通过线程切换再加用户

  - 但是最多就开core_count*2个线程

- 用户多就开大是错误的：线程切换太大，不要有太多连接；

- **连接池大小和用户数前端 没关系（不要开多连接数**

  - 上面的公式中连接数已经是数据库效率最高的方式

------



# 异步通信 JMS

#### 为什么要异步通信

同步通信的缺点：

- 紧耦合：没有变化保障
- 没有送达保障：过多 / 挂了（通信不可靠的时候） 都调不出来
- 软件物种化：
- 没有请求缓冲：太忙了直接失败
- 过于强调请求和响应（Too Much Emphasis on Requests and Responses）
- 通信不可重放（Communication is not Replayable）

------



#### 异步模型

没有客户端和服务器的区分，client和server都和kafka cluster这个中间件交互（kafka就是帮助异步通信的中间件）

发信息，发完后可能没有及时响应，但之后一定会完成；发完消息后不用等待

- 后端异步（甚至是不同层之间都可以）：
  - 防止请求过多 丢失；请求放到消息队列，服务什么时候有空了就去处理
- 异步通信的优点（其实同步通信的缺点就是异步的优点）：
  - 不会产生因为service忙而请求被丢失的问题
  - 很好地利用了空闲时间和空闲资源



#### topic 消息缓冲区（消息队列）

- producer发送消息到队列topic中（string
- consumer不断从topic中拿string并解析成对象



#### client如何知道处理完成

1. **client 发ajax获取：轮询机制查询**，无需中间件比较灵活，但严重增加服务器负载，造成不必要的带宽浪费

2. **websocket：**实时更新，双向工作，节省了带宽通信量，可以保持持久连接；保持连接讲持续占用服务器资源，老浏览器不兼容

3. **服务器把结果推到另一个topic**，client监听该消息队列，发现非空后就将内容取出得到结果：

   - 直接交互，不需要单独写新接口（都运行kafka监听）；复杂，客户端直接与Topic连接，**Topic直接暴露**，需要确保消息传递的安全性

     

#### 完整详细过程：

1. 前端发起的请求会发到中间件的某个topic（假设为topic A）里面。**此时后端会直接给前端发回一个ok响应，并在后续的步骤异步处理请求**
2. 一旦服务器接口空下来，它就会去扫描对应topic（topic A）看看里面有没有请求，一旦有就将消息取出，转换成json格式，然后进行处理。
3. 同时服务器处理完请求后，会将结果存入另一个topic（假设为topic B）
4. client也会在空闲后扫描topic B，发现非空后就将内容取出得到结果
5. 即service会监听topic A，client会监听topic B



### 应用场景

- **有忙有闲，闲的时候处理忙的时候的缓存请求**

  - **一直忙：增加机器**

  ![1736608390063](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736608390063.jpg)

- 上图中：就是在请求密度很高的时候，仍旧较为平稳地处理请求（虽然我也看不太懂画的啥玩意）

- 问题：client如何知道结果是否成功

------



## JMS Java Message Service

- 消息传递异步

- 通过异步达到高可靠性：发完消息，不管consumer在不在线，都会先缓存，直到在线了再发；不会发完直接失败

- 客户端

- 消息中间件，消息触发



#### JMS API 特性

- 允许Application clients（本来的发请求、处理请求的都算这种）
- 规定了Message send and receive operations



#### message格式

message的格式是弹性的，包含以下三个部分：

- A header
- Properties（可选的）消息属性，是对消息头的补充
- A body（可选的）消息体
- 消息可以没有消息体、属性，但是一定有消息头



- 怎么发消息

  - 消息转化为纯文本：特定格式 （header + *properties + *body）

    - 消息模式：可能发不到就不发了：对时间顺序敏感：先2后1有问题(time stamp 属性)，晚发的消息1会被忽视

      ![1736651438701](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736651438701.jpg)

  - 扩展规则：可用来指定接收者等等

    ![1736651507874](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736651507874.jpg)

    - Property name
      - 即使在同一个topic下，也可以通过name对于收到该信息的service做区分（select）
      - 比如所有班级的家长都往一个邮箱里寄信，两封信中的name起为A和B，那A和B学生就能拿到对应的正确的信（虽然在一个邮箱里）
    - Property value

    

JMS的消息体类型

JMS的消息体类型：

- TextMessage：转成String类型就可以存
- MapMessage：就是Java的Map类
- BytesMessage：字节数组
- StreamMessage：任意一个流（必须是基础类型的）
- ObjectMessage：对象一定要能够被对象化
- Message：body为空，是上面五类的父类对象
  - 当你不知道传过来的Message是什么类型的时候就用这个

![1736651705682](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736651705682.jpg)



#### JMS API Architecture

![image-20240929213456517](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20240929213456517.png)

- Destination(D)分为两种
  - topic
  - queue
- JMS Client（收发消息的都算client）
  - 先通过连接工厂找到一个到JMS的连接，才能够进行收发消息
  - Messaging Styles 有两种
    - 发送消息的模式是ptp（point-to-point）
      - 如果client1发送的消息2接收到，3不会受到消息
    - publish/subscribe 广播模式
      - 每个message可以有多个consumer



#### JMS消息传输模型

1. **点对点（Point-to-Point，P2P）模型**：

- 在这个模型中，消息生产者发送消息到队列（Queue），消息消费者从队列中接收消息。
- 每个消息只能被一个消费者接收，一旦消息被消费，它就会从队列中移除，确保消息不会重复处理。
- 这种模型**适用于需要确保消息只被处理一次的场景**，例如订单处理、用户请求处理等。

![1736651840924](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736651840924.jpg)

2. **发布/订阅（Publish/Subscribe，Pub/Sub）模型**：

- 在发布/订阅模型中，消息生产者（发布者）将消息发送到**主题（Topic）**，而消息消费者（订阅者）订阅感兴趣的主题。
- 一个发布者发送的消息可以被多个订阅者接收，这使得发布/订阅模型**非常适合需要一对多通信的场景**。
- 订阅者可以设置过滤条件，只接收满足特定条件的消息，这增加了消息传输的灵活性。

![1736651959817](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736651959817.jpg)

两种模型的特点对比：

- **一对一 vs 一对多：**
  - P2P模型是一对一的消息传输，每条消息只有一个消费者。
  - Pub/Sub模型是一对多的消息传输，一条消息可以被多个订阅者接收。

- **队列 vs 主题：**
  - 在P2P模型中，使用队列作为消息的容器，队列**保证了消息的顺序性和独立性。**
  - 在Pub/Sub模型中，使用主题作为消息的发布点，主题允许多个订阅者接收消息。

- **消息确认：**
  - 在P2P模型中，消费者通常需要显式确认消息，告知消息服务器消息已被成功处理。
  - 在Pub/Sub模型中，订阅者可能需要确认消息，也可能不需要，这取决于具体的实现和配置。

- **消息持久性：**
  - 在两种模型中，都可以配置消息的持久性，确保消息不会因为系统故障而丢失。

JMS的这两种消息传输模型为不同的应用场景提供了灵活的消息传递机制，允许开发者根据业务需求选择合适的模型来实现消息通信。

![1736652058797](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736652058797.jpg)



### 异步通信 - kafka

- 消息中间件
- **发布/订阅模式**，存储转发
- 基于日志实现：append-only只追加：在后面不断更新
  - 顺序写：速度快
- 对不同用户维护不同用户读的index
  - 不同用户按自己的进度读 不会读乱
  - 当一个消息被所有的消费者读走了之后，这个消息 才会被删除掉；多个用户可以读取同一个log，并且维护他们各自的文件位置（都到哪里了）这样就能保证log文件不可能无限制的增长
- 如果一个topic放相同的对象：每个对象长度相同，通过偏移量快速定位
  - 种类多，topic多
- 如果一个topic记录多种类型：每个都要记录起始位置和长度

#### 分区

- 加快处理，逻辑自己指定
- 不同用户处理不同的区
- 对于集群的容灾：用空间换可靠
  - 比如每个数据存储两个副本，这样比如有一个卡夫卡服务器崩溃了，还有一个**备份**能够使用。
- 检测死没死：**心跳**：
  - 此时就需要一个协调器在kafka集群里面，consumer一直发心跳包给协调器，如果不发协调器就不会再把消息给故障的机器。



### websocket

- **全双工**（双向都工作）通信，request端和response端完全对等，即用户可以主动给服务器发消息，服务器也可以主动给用户传递消息。底层使用TCP协议（安全保证）
- 服务器发布（publish）一个 WebSocket 端点**endpoint**，客户端使用端点的**URI**连接到服务器。

WebSocket分为两部分：**握手（handshake）和数据传输（data transfer）**



#### 握手（handshake）

1. **客户端发起 WebSocket 握手请求：**客户端通过使用其URI向WebSocket端点发送请求来启动握手。握手（handshake）与现有的基于HTTP的基础设施兼容，Web服务器解释其为HTTP连接升级请求
2. **服务器响应 WebSocket 握手请求**
3. 客户端收到服务器的响应后，验证 `Sec-WebSocket-Accept` 是否正确。如果验证通过，服务器和客户端就可以互相发送消息了

**Sec-WebSocket-Accept 的生成：**

- 服务器对Sec-WebSocket-Key标头的值应用已知操作，以生成Sec-WebSocket-Accept标头的值。
- 客户端对Sec-WebSocket-Key标头的值应用相同的操作，如果结果与从服务器接收到的值匹配，则连接成功建立



#### 如何创建并部署一个endpoint：

1. 创建端点类（endpoint）
2. 实现端点的生命周期方法（发送、接受信息的时候要做些什么事情）
3. 将您的业务逻辑添加到端
4. 在web应用程序内部部署端点

开发中一般使用annotation的方法实现endpoint



#### 一些WebSocket的生命周期方法：

![image-20241009085143942](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20241009085143942.png)

- OnOpen：建立连接的时候要做什么
  - 封装好session并写入list，这个list在发消息的时候会遍历这个list
- OnMessage：收到消息的时候
- OnError
- OnClose



#### 维护session list

创建端点的的时候也会为它建立一个session list并维护（将所有的session按顺序放进去）

- 连接后是通过session发消息
  - send的时候就会需要拿到每个session并将消息广播出去（也可以指定具体的接收者）

- sessionlist要求是线程安全的（可能多线程）
  - 如果不是线程安全的可能会导致数据丢失甚至崩溃



#### 编码器 解码器

发消息的时候使用

- 可以增加编码器和解码器
- 将对象decode成方便发送的格式



#### 通信机制共存

![1736653099137](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736653099137.jpg)



### transaction 事务

只有100张票的东西却有200个人同时并发在抢，如何控制不会出错，确保数据库中的状态是一致的

- 不会因为并发请求同时处理使得数据库的数量出问题

如何确保两个操作是原子性的？（即要么都发生要么都不发生）



需要使用java中的transaction

- 要么全部执行
- 如果部分执行则要对执行了的部分进行回滚



#### Java Transaction Api（JPA）

- 支持声明式的事务控制
- **begin transaction，先扣钱、再存钱、再更新操作日志，commit transaction**
  - 原子性问题，上述即为达到transaction的伪代码



#### 事务的定义：

一系列必须全部成功完成的操作，要么都执行，要么都不执行（事务回滚）



#### 显式使用transaction的不同方法

没有显式使用transaction之前，bean都是用container管理的

- 比如methodA要调用methodB
- 进入methodA，该线程就会依附上一个事务TX1
  - TX1肯定要在methodA执行完毕后才会尝试提交/回滚
- 调用methodB时，该线程会进入哪个事务执行呢？
  - 这就由下面的不同状态来定义



#### 六种@TransactionAttribute的状态：

methodA中调用methodB

- Required
  - 在方法前面加注解@TransactionAttribute(REQUIRES)
    - 也可以在整个bean上面加
  - 有加入，没有新建
  - 在调用methodB（B也为Required）的时候，会将methodB加入到调用它的方法的事务，即methodB执行的时候也在事务TX1中
    - methodB执行结束后，TX1会检查是否能提交/回滚，但是因为是A创建的所以不能
    - 返回到methodA结束后，TX1才能最终选择提交/回滚
  - 适用于绝大多数情况，**确保所有相关操作要么一起提交，要么一起回滚**
- RequiresNew
  - method B会开一个新的TX2，method B执行结束之后就会执行一次提交/回滚，成功与否不影响A
  - 新建一个事务，原有事务被暂时挂起
  - 用于需要方法独立执行、避免与外部事务干扰的情况
  - 若A中有方法B，若A为Required，B为RequiresNew,那么B发生错误不会影响A
    - 比如上述问题，不希望log操作失败就将扣钱、存钱也进行回滚，所以将log声明为RequiredNew。
- Supports
  - B在A的中执行状态下执行
  - 即无论A有没有事务，B都和A在相同的事务/没有事务的背景下执行
  - 用于可选择性的事务操作，事务性并不是必需的
- NotSupported
  - None，当前方法不支持事务。如果调用时有事务存在，事务会被挂起，方法执行完成后再恢复原来的事务；挂起现有事务，无事务支持
  - 如果B为NotSupported，则调用B时会先将A的TX1挂起，然后在非事务的状态下执行B，再回到A进行执行
  - 当不希望方法在事务上下文中运行时，比如不需要事务保证的一些只读操作
- Mandatory
  - 如果A有事务就加入，如果A没有事务就抛出异常
  - 强制要求方法必须在事务中执行
- Never
  - 和Mandatory恰好相反，在事务里抛出异常，不在事务里则正常执行（也不会创建事务）
  - 需要确保方法绝对不在事务中执行时

![image-20241009082354142](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20241009082354142.png)

![1736653548289](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736653548289.jpg)



#### 事务四个属性：ACID

- a：atomic原子性（可以使用双required确保整个事务回滚）
  - 不可分割性，事务单元全部成功或者全部失败
- c：consistency 一致性
  - 一个正确（一致）的状态转移到另一个正确的状态
  - 比如银行存款无论怎么扣都要确保值不能是负的

- i：isolation 隔离性，互不干扰
  - 多个事务在并发执行的过程中所得到的结果，和串行执行得到的结果一致
  - 解决A和B做并发操作时，做到不会卖重复
- d：durable 持久性
  - 永久保持，执行结果不会丢失（数据库要保证提交的东西绝对不会丢失）
    - 通过undo log和redo log来确保
  - 只要正常提交，数据库中的数据变化就一定长久可见



#### Isolation

事务隔离级别控制的是**同一时间内多个事务如何相互影响数据可见性**的问题。

#### 隔离性冲突总结

| **写读冲突** | **脏读**       | 事务A读取了事务B修改但未提交的数据（读到了事物处理的**中间状态**），事务B随后回滚，导致A读的数据无效。（解决：不能读中间状态 |
| ------------ | -------------- | ------------------------------------------------------------ |
| **写读冲突** | **不可重复读** | 事务A第一次读取数据后，事务B修改并提交该数据，事务A再次读取时数据被修改。（解决：读了就锁 |
| **读写冲突** | **幻读**       | 事务A执行范围查询后，事务B插入/删除了满足条件的记录(但B还没确定)，事务A再次查询时不同。（解决：将整个table锁住 |
| **写写冲突** | **脏写**       | 事务A和事务B同时修改同一条记录，事务B的提交覆盖了事务A的修改。 |

- 写读冲突的例子：
  - 事务A：小明账户存款100元
  - 事务B：家长查询小明存款
  - 如果事务A、B并发执行就会导致dirty read脏读
    - 比如如果B读取到了A的中间状态，因为不知道A最终会提交还是回滚，此时B读到的数据就可能是错误的
- 不可重复读的例子：
  - 两个人抢同一张票，一个人先读到了还有一张，然后进行购买流程。另一个人在前一个人进行购买流程的时候也读到了还有一张，但是准备买的时候前一个人下单成功，导致读到有票，可是要买的时候票没了。
- 幻读：如果表里插入了新数据，且满足query的条件，查询时不断会有满足条件的新数据出现



#### **Read Uncommitted：**

- **特性**：允许一个事务**读取另一个未提交事务的修改**，可能发生**脏读**（Dirty Read）。
- **优点**：并发性能较高；
- **缺点**：最低的隔离级别，可能会看到未提交的数据变化。

#### **Read Committed：**

- **特性**：**只能读取已经提交的事务修改**，避免了脏读，但可能发生**不可重复读**（Non-repeatable Read）。
- **实现原理：**增加写锁
- **优点**：大多数数据库的**默认级别**，保证每次读取的数据都是已提交的；
- **缺点**：同一事务中，连续读取同一条数据可能会不一致。

#### **Repeatable Read：**

- **特性**：**保证同一个事务中多次读取的数据是一致的**，解决不可重复读的问题，但可能会发生**幻读**（Phantom Read）
- 实现原理：增加读锁。
- **优点**：确保读取的记录在事务期间不发生变化；
- **缺点**：仍可能有幻读问题（即插入新数据时的并发问题）。
- **解释**：与不可重复读的区别在于，**不可重复读**是针对**已存在的记录**的修改，而**幻读**则是因为**并发事务插入或删除了新的记录**，从而影响了查询结果集的条目数量或内容。对一个同一个List在同一事物读取，第一次读到10个，第二次读到11个，因为中间插入了一个数据。

#### **Serializable：**

- **特性**：**最高级别的隔离，事务之间完全隔离**，仿佛事务是一个接一个顺序执行的，解决了幻读问题。
- **优点**：提供了最高的事务一致性；
- **缺点**：没有任何并发，完全时串行的操作
- 所以很少使用，因为性能实在太差

SQL：JDBC的连接是什么属性，是在数据库里设置的

![image-20241009084631321](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20241009084631321.png)

------



### 多数据库 分布式事务

#### 两阶段提交协议

![1736657541612](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736657541612.jpg)

- 两阶段：
  - 第一阶段prepare
  - 第二阶段commit
- 启发式：网断了，不知道manager的决定，从提交/回滚中猜一个
- 但是无法避免第二阶段的启发性错误



#### 并发锁

- 乐观离线锁 optimistic offline lock（认为读多写少
  - 离线：从数据库拿走之后自己玩
  - 在会话提交更改之前，会进行冲突检测。如果检测到冲突，则会话无法提交更改
  - 加版本号version int
  - 写的时候和读的时候版本号不一样，冲突
  - 这玩意就是cse里面那个乐观多版本锁机制
- 悲观 Pessimistic Offline Lock （认为写多
  - 读了就锁
  - 浏览次数（更改很多的情况
- **粗粒度锁** Coarse-Grained Lock
  - 锁多张表（一个锁）
    - 乐观锁：共享version，写的时候检测version
    - 悲观锁：统一一个锁锁版本号对象， 读就锁

事务在资源管理器来管的，不会管内存，需要维护过这个对象之前的状态；是在对事务性的对象做



## 数据库事务管理 log

### 调度

为了更好解释并发控制过程中，数据库对事务的处理流程而引入的

定义：事务并发过程中，决定事务中每个操作的执行顺序

- eg:小明要扣款100元，分为三步
  - 读取小明余额
  - 计算扣款情况
  - 将扣款后金额存回数据库

假如有两个事务，T1为消费100元，T2为消费200元

- 若**串行调度**，慢但是正确
- **并行调度**快，但是可能会出现错误的情况



#### 调度定义下的并发控制：

- 给定一个并发调度S'，存在一个串行调度S，在任何数据库状态下，按照S和S'执行后产生的结果都是相同的。
- 此时调度S'被称为**可串行化调度**



#### 可串行化调度

- 数量十分巨大，且难以校验
- 数据库中一般通过找到可串行化调度的子集（充分条件），即找到能提前确认为可串行调度的并发调度
  - 即找出来一个能用的就行，不用找出所有的然后选最优
  - 找的方式：冲突可串行化调度
- **操作交换：**定义为交换事务调度序列中相邻的两个操作，一次交换操作可以将一个调度A变为另一个调度B
  - 当交换不会影响两个调度的一致性，则称该交换得到的两个调度是等价的，该交换为等价交换
    - 等价操作：交换连续两个相同数据读取操作的顺序
    - 等价操作：交换连续两个不同数据读写操作的顺序
    - 非等价操作：交换连续两个相同数据读写操作的顺序
- 如果一个并发调度可以通过等价交换变为一个串行调度，则认为该并发调度是安全的
- 但如果使用不等价交换就可能出现冲突



#### 冲突可串行化调度

- 定义：从冲突的角度出发，针对一个调度S（可能存在冲突）去发现其等价的串行调度S'来确定S是一个可串行化调度
  - 是一种特殊的确定是否是可串行化调度的方法

- **验证是否冲突可串行化**：（对同一数据的冲突连线

  ![1736658407308](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736658407308.jpg)

  - 要求为优先图（无环，有环就非冲突可串行化

  ![1736658500316](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736658500316.jpg)

##### 结论：如果调度S‘中T~i~,T~j~的某两个操作存在冲突，且T~i~的冲突操作在T~j~之前。若调度S'存在冲突等价的串行调度S，则在串行调度S中T~i~一定在T~j~前面



### 事务原子性和持久性的实现

#### 原子性

- 事务运行期间不刷盘，故障系统重启后自动保证原子性
  - 优点：在事务提交前绝对不会写到硬盘中，使得回滚特别方便
  - 缺点：事务中处理的事情如果多，会占据很多空间
- 事务运行期间刷盘，故障系统重启需回滚该事务
  - 优点：内存占用小
  - 缺点：如果遇到故障重启，恢复事务需要进入硬盘进行回滚，比较麻烦

#### 持久性

- 事务完成（commit/abort）时刷盘（即一完成立刻刷盘），自动保持持久性，磁盘IO次数多——undo
- 事务完成时不刷盘（可能等到脏页写到一定数量后统一刷盘），故障系统重启后需重做该事务，磁盘IO使用少——redo



#### 数据库故障类别：

![1736658703835](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736658703835.jpg)

1. 事务故障
   - 资源冲突或死锁等原因导致失败
   - 只会影响原子性
2. 系统崩溃
   - 数据库自身或操作系统故障
   - 可能会影响持久性
3. 磁盘故障
4. 自然灾害

后两种显然无法避免损失



#### 数据库恢复机制架构

![1736658810193](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736658810193.jpg)

1. 无故障事务回滚（例如余额小于0）
   - 影响原子性，撤掉该事务已做操作
2. 故障事务回滚（如死锁杀死事故）
   - 影响原子性，撤掉该事务已做操作
3. 系统故障（如重启）：丢失内存数据，影响原子性、持久性
   - 原子性：**撤销**未结束（不带commit，abort标记）的事务
   - 持久性：**重做**已经结束（带commit或abort标记）的事务
4. 系统崩溃不能重启：不能提供服务，影响持久性
   - **一主多备**：主备之间通过日志保持一致性，发生故障后切换到其他系统
5. 磁盘故障：影响持久性
   - 磁盘数据多副本；数据备份机制：数据备份，日志备份
6. 自然灾害：
   - 异地多机容灾



#### 系统崩溃恢复

- **脏页：**内存页面已更新，磁盘页面未更新
- **刷脏：**将内存脏页刷到磁盘
- 如果事务在崩溃时刻前已经提交
  - 若未刷脏，则影响持久性，需重做——redo
  - 若已刷脏，则不影响持久性
- 若崩溃时刻前已经中止（abort且已经完成回滚）
  - 如果期间刷过脏，但abort时未刷脏，则影响持久性，需重做（事务部分操作已经落入磁盘，且abort操作未将磁盘中回滚）——redo
  - 如果已刷脏，则不影响持久性
- 若崩溃时刻前未结束
  - 如果已刷脏，影响原子性，需要回滚——undo
  - 如果未刷脏，不影响原子性

汇总：一般情况下，完成未刷脏重做redo；刷脏未完成回滚undo

![1736658915606](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736658915606.jpg)



#### 崩溃恢复策略设计：

- 原子性保证（这个开关在mysql里是可以打开的）
  - 选择：NO-STEAL(非窃取)
    - 未结束事务不能刷脏，不存在原子性问题
    - 占用内存大
  - 选择：STEAL(窃取)
    - 未结束事务可刷脏，影响原子性，需要undo
    - 占用内存小
- 持久性保证
  - 选择：Force（强制）
    - 已完成事务**强制立刻刷脏**，不存在持久性问题
    - IO frequency高，性能差
  - 选择：NO-Froce（非强制）
    - 已完成事务**不强制刷脏**，影响持久性，需要重做
    - IO frequency低，但是影响持久性

![image-20241018134408570](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20241018134408570.png)

维持原子性：undo日志

维持持久性：redo日志



#### 数据页面写回磁盘时机

- 数据库同步写内存数据页，但**异步写回磁盘**
- 刷脏时机（一般不会选择事务完成立刻刷脏，而是如下策略）：
  - 数据库关闭时，所有脏页写回
  - 缓冲区中数据也已满，将被替换脏页写回
  - 数据库设置单独线程定时刷脏
    - 比如进行了1000次写操作后刷脏一次
- 难点：遇到故障如何靠日志回滚



#### 日志

日志是log record的序列，记录了数据的更新，和数据库事务开始/结束的逻辑

日志是磁盘文件

- 日志文件写入后不可修改，即顺序写入，几乎没有随机访问的需求
- 所有日志内容可以顺序写入，提供了高效的写入速度，不影响对数据库的操作性能
- 如果日志太大了会进行截断

日志的分类

- redo log：重做已提交事务的修改，确保数据**持久性**
- undo log：回滚未提交事务的修改，确保数据**一致性**



#### Undo回滚日志

- 格式：<T,X,V~old~>
  - T：事务的唯一标识符
  - X：数据项
  - V~old~：数据项修改以前的值（**记录的是操作前的旧值**）
- 产生时机：当数据T修改数据项X时产生（先日志后执行）
- 作用：实现事务回滚
- 注：一般还包括一个日志序号LSN
- 使用方式：反向扫描（cse讲过的那个）

![image-20241018142005671](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/image-20241018142005671.png)



#### Redo重做日志

- 格式：<T,X,V~new~>

  - T：事务的唯一标识符

  - X：数据项

  - V~new~：数据项**修改以后**的值（新值）

- 产生时机：当数据T修改数据项X时产生（先日志后执行）
- 作用：实现事务重做
- 使用方式：正向扫描



#### 预写日志 WAL

- 数据库日志需要满足预写日志，即**日志必须比数据更早的写入磁盘**（即先日志后执行）
- 日志写入顺序必须和生成时间一致
- 原子性保证：页面写回磁盘时和事务相关的undo日志需要先写回
- 持久性保证：事务提交的时候，和事务相关的redo日志需要先写回



#### 日志实现方式

- 功能
  - undo日志
  - redo日志
- 按照性质分类
  - 逻辑日志
    - 记录高层抽象的逻辑操作
    - 日志量较小，解析速度慢
  - 物理日志
    - 记录数据库具体物理变化
    - 日志量较大，解析速度快
  - 物理逻辑日志
    - 日志记录中包含了数据页面的物理信息，但页面以内的是以逻辑的形式记录的
    - 日志量中等，速度较快



#### 日志的重要性质

1. **幂等性**：一条日志记录无论执行一次或多次，得到的结果都是一致的
   - **物理日志满足幂等性，逻辑日志不满足**
2. **失败可重做性**：一条日志执行失败后，是否可以重做一次达成恢复目的
   - **物理日志满足，逻辑日志不满足**
     - 比如一个逻辑日志的插入数据页面操作。如果插入页面成功而插入索引失败，不能重做，如果重做会报错
3. **操作可逆性**：你想执行日志记录的操作，可恢复原来状态
   - **物理日志不可逆，逻辑日志可逆**

不同日志的各种信息汇总：

![1736659409024](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736659409024.jpg)

redo日志一定是物理日志

- 逻辑日志不具有可重做性，所以不能用于redo

undo日志可以是逻辑日志可以是物理逻辑日志。所以不具备幂等性

- 物理日志不具有可逆性，所以不能用于undo



### 恢复算法

![1736659558786](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736659558786.jpg)

![1736659570763](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736659570763.jpg)

![1736659578571](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736659578571.jpg)

![1736659621147](new_%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.assets/1736659621147.jpg)

补偿日志：Undo日志的redo日志：每次执行undo日志记录后，数据库需要向日志中写入一条补偿日志记录（compensation log record，CLR），记录撤销的动作

- 目的：undo不是幂等的，防止做多次



### 作业3

1. 如果数据库系统在事务执行过程中不断地将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

事务原子性可能出现问题：在事务完成前程序发生崩溃时，事务全部都不应该落盘，但因为执行过程中不断刷脏，导致一些操作已经落盘了，从而不能保证事务的原子性（要么全部成功要么全部失败）

处理：采用undo log，系统崩溃后，可以通过反向扫描相关的undo日志，执行回滚。

2. 如果数据库系统在事务执行提交后再将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

执行期间不刷盘、事务提交后强制刷盘可能会：事务执行过程中不能刷新磁盘，必须占有较大的缓冲区空间，不利于多个事务的并发执行；每次事务提交都必须刷新脏页，消耗大量IO读写资源

处理：使用STEAL模式，利用Undo日志撤销事务；使用NO-FORCE模式，利用Redo日志重做事务；



## multithreading 多线程

- 进程：进程有一个自包含的执行环境；进程间内存隔离，互相访问不了；
  - 进程间通信：RMI / Http，RMI通信方式：类似于Server和Client，用Serializable，流的方式传递
- 线程：线程有时被称为轻量级进程。
  - 进程与线程的关系和区别：
    - 进程和线程都提供了一个执行环境，但创建新线程所需的资源比创建新进程少。
    - 线程存在于进程中——每个进程至少有一个线程；线程共享进程的资源，包括内存和打开的文件。这有助于高效但可能存在问题的沟通。

为什么java虚拟机中只说multithread不说multi-process：

- 因为java虚拟机本身就是一个进程，它不可能支持多进程



#### **创建线程**

- 手动创建一个线程，这个线程执行完就结束了。（人为的管理、控制线程）
- 两种实现方式
  - 实现Runnable这个接口（推荐使用这个，因为Java里面只能继承一个类，但是实 现可以实现多个接口）
    - 这个接口里只有一个run方法，这里面写着线程要做的实现
    - 更推荐用这个
      - 涉及到java中单根继承的问题：任意一个类只能扩展自一个类，**一旦它本身是一个扩展类，它就不能被别人所扩展**
  - 继承Thread类（Java是单根继承，和cpp不一样，所以这种方法不推荐）
    - thread类里有一些方法
      - sleep()
      - interrupted()
        - 用来判断线程是否被中断，返回的是一个bool值
      - interrupt()
        - 用来中断某个线程
      - join()
        - t.join()，表示停止当前线程的执行，直到t这个线程终结



#### **中断与存活函数**

- 中断一个线程，调用Thread.interrupt（）方法，让其抛出InterruptedException异常
- 判断是否存活，调用Thread.interrupted(）

#### **join**

- join方法允许一个线程等待另一个线程的完成。如果t是线程当前正在执行的Thread对象，t.join（）

使当前线程暂停执行，直到t的线程终止。和sleep一样，join依赖于操作系统的时间，设备好理论就快，所以你不应该假设join会等待你指定的时间。也和Sleep类似，join通过发出InterruptedException退出来响应中断。



#### **线程间通信**

线程之间主要通过**共享字段**以及**字段引用的对象**来进行通信。这种通信方式非常高效，但可能会导致两类错误：

- **线程干扰**（Thread Interference）：比如多个线程有些在消费有些在充值
- **内存一致性错误**（Memory Consistency Errors）：可能会因为多个线程同时操作数据库，导致内存一致性错误

The tool needed to prevent these errors is **synchronization：解决竞争问题**



#### Synchronization

有synchronazed标记的所有方法共用**该对象**的锁，一个方法执行完才能执行下一个

- 在 **Java** 中，每个对象都隐含地拥有一个**内在锁**（也称为**监视器锁**
- 调用这些方法之间之前要获得这把锁，必须执行完一个操作，另一个操作才能获得这把锁（对象的内部锁）
- Synchronization是基于java中的intrinsic lock实现的，是一个内部锁，每个对象只有一个锁

即使是调用的这个类的static方法，static方法不是属于对象的，是属于这个类的

- 但是类本身（类也是一个对象）也会有自己的对象锁，所以static synchronized也能起到作用

**同步语句——细粒度的控制：**放在语句前，在语句执行前获得对应对象(可以指定)锁

**可重入的锁： ReentrantLock：一个线程**不能获得一个被其他线程占据的lock；但是它能够**获得一个它已经拥有的锁**：我们有一个类 C ，它有一个Synchronized方法 m ， m 里面调用了另外一个Synchronized方法 n ， n 也在 C 里面；这个时候我们发现按照我们前面的逻辑就蚌埠住了。调用 n 的时候，发现这个对象的锁在 m 手里

- 所以java的synchronized关键字实现的内部锁是一把可重入锁



#### 原子变量

除了 long 和 double 之外，其他的基本类型都是原子的。如果我们想要把一个变量变成 原子变量，只需要在变量定义的前面加一个 volatile 修饰就可以了。



#### **Liveness：多线程碰到的各种问题**

- **死锁**：A线程等待B，B等待A，这样就会陷入死锁的循环
- **饿死** starvation ：A想要访问一个共享资源，但是一直获取不到，就像被饿死了一样。（需要消除那些贪婪的线程，避免一个线程长期贪婪的占用资源；所以tomcat里面用了连接池，避免一个连接长期占用资源）
- **活锁**：活锁是指一个线程对另一个线程的动作做出反应，而如果另一个线程的动作也是对前一个线程动作的反应，那么可能会导致活锁

**解决方式：协调资源**

1. **受保护的块（guarded block）**。 最常见的方式，while(!joy) {}简单的循环，但浪费处理器时间。一般不推荐这么做（没有上下文切换的开销
2. 调用`wait`方法会暂停线程，直到另一个线程发出通知**Object.notifyAll**(通知所有等待该锁的线程，表示某个重要事件已经发生，具体谁抢到锁不一定)



#### **Immutable Objects 不可变对象**

如果一个对象的状态在构造之后**不能更改**，那么该对象被认为是不可变的

**一定要改：创建新对象**

缺点:每次更新都要创建一个新的对象，因此大多数程序员不太愿意使用不可变对象，认为开销比较大。

**程序员常常不愿使用不可变对象**，因为他们担心创建新对象的**成本**，而不是直接在原地更新对象。但对象创建的影响常常被**高估**，因为**垃圾回收**带来的开销减少和**无需编写额外的代码**来保护可变对象不受损坏，且可以通过不可变对象带来的一些效率来**抵消**。

#### Synchronized问题

方法是同步的，但在getRGB和getName 之间 颜色直接被另一个线程改了



#### **高级并发特性**

- `Lock` 对象：`tryLock` 方法在锁不可用时立即退出，或者在超时之前退出（如果指定了超时时间）。`lockInterruptibly` 方法在另一个线程发送中断信号时退出，前提是锁尚未获取。
- `Executors`类提供了线程池管理的实现，避免了手动创建和销毁线程的麻烦；里面有一组线程，要线程就从里面找：
  - fork / join：是一种 `ExecutorService` 的实现，设计用于可以递归拆分为较小任务的工作负载
- **并发集合：**并发集合类（如 `ConcurrentHashMap`：通过采用了分段锁的设计，允许多个读线程并发地访问map，并且允许多个写线程并发修改不同的段。）允许多个线程安全地访问集合，无需手动添加同步块。通过分段锁定技术，实现高效的并发操作，减少了锁竞争
- **原子变量 ：**允许线程安全的变量操作，无需显式使用锁
- **ThreadLocalRandom：**每个线程独立生成随机数的方式，避免了传统 `Random` 类在多线程下的竞争问题。

------

- **虚拟线程：**不跟操作系统线程绑定：轻量级线程，可以减少编写、维护和调试高吞吐量并发应用程序的工作量。更加轻量化，比如在被IO阻塞时，那么就把线程解绑；等IO结束时再绑定线程，但不一定是原先的线程。但对于长时间占用cpu的任务不友好
- 平台线程（Platform Thread）：平台线程是一个围绕操作系统（OS）线程的轻量级封装的Java线程。可用的操作系统线程数量决定了平台线程的数量限制；具有较大的线程栈（存储线程执行状态的内存）以及其他由操作系统管理的资源。













