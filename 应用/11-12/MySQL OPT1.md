上面的所有内容是关于服务端的问题，从这里开始讲数据库的知识：

- 关系型数据库的优化
- 非关系型数据库（5种：mongoDB，influxDB，图数据库等）

# MySQL OPT1

### 多层次优化的方面（这部分的目录）

- #### 数据库层次

  表的结构的合理性：

  - 是否每列的数据类型合(char,varchar); 
  - 合适的索引; 
  - 存储引擎：Mysql主要是InnoDB;
  - 行格式：比如学号前几位一样可以压缩之类的
  - 锁机制
  - caching配置大小

- #### 硬件层次

  - 磁盘寻址操作
  - 磁盘的读写：HDD和SSD
  - CPU和内存

不管怎么优化必须平衡可移植性和性能，在使用SQL的extension功能后要使用/ * ! * /注释声明

## 索引

### **作用**

在使用SELECT操作时，在一列或者多列上创建索引会加快搜索速度。

- **举例1：**大部分是B树和B+树索引，第一个好处是建立一个多叉树，考虑到了内存页的尺寸，每次读入数据时不会有很多的空间浪费；第二个好处叶子节点有指向兄弟节点的指针，范围搜索很快；

- **举例2：**空间索引用R tree，mongoDB详述；内存里临时表索引使用哈希map，比较浪费空间（桶源多一点）

- **举例3：**InnoDB使用inverted lists进行FULLTEXT 索引

- **举例4：** Cluster Index聚簇索引（树中兄弟节点的顺序和物理存储的顺序一致）默认在主键上建立，可以建到经常搜索的数据上；一个表一个。

  ps：B树和哈希比较

  - B树适合做范围查找，也适合like查找（但是第一个前缀不能是通配符）始终是最左索引
  - 哈希索引适合对于=或者不=十分友好，不可以排序

**具体应用在哪些操作上？**

- 快速查找与WHERE子句匹配的行。
- 从考虑中排除行。
- 如果表具有多列索引，则可以使用索引的最左边的任何前缀来查找行。
- 在执行连接时从其他表检索行。
- 查找特定索引列key_col的MIN（）或MAX（）值。
- 如果排序或分组是在可用索引的最左边的前缀上完成的，则对表进行排序或分组（例如，ORDER BY key_part1, key_part2）。
- 在某些情况下，可以对查询进行优化，以便在不查询数据行的情况下检索值。

### **实质**

把那一列的东西都搬了出来建了一棵树，所以空间大小其实就是做了一个 duplication。我们在支持的时候，是把索引 load 到内存里的，索引命中的时候，就对应的硬盘上的位置，我们就可以直接寻址过去。

- 建立索引要花费时间和空间，维护一颗树也需要成本
- 追求一个平衡，如果表本身就很小，索引的成本超过了scan的成本，所以不需要索引。

### 主键和外键

- 主键如果由太多的列构成，那么这个建立索引的效率就不太好，可以生成一个**基于整数递增**的列来建立索引
- 主键是默认不为空的，但是如果在**为空的列上上建立索引**有3个坏处：
  - 允许某列为空是在这个存储单元之后最后一个bit位，用01表示是否为空，空间浪费
  - Mysql操作时总是要check是否为空，浪费时间
  - <img src="C:\Users\77043\Desktop\1.jpg" alt="1" style="zoom:37%;" /> 挂一串很长null的东西，索引失去意义，所以最好设计不为空

可以把使用频率比较低的数据列和其他分开（比如：书籍简介单独开一张表，使用bookid关联）好处：

- 可以一次读入更多更常使用的数据
- 可以把这些放入其他数据库（图数据库。。。）

### 列索引

如果一列太长怎么建索引？可以只使用前N个字串来索引（比如只搜索title的前3个词）

N怎么选择：行格式REDUNDANT COMPACT  DYNAMIC  COMPRESSED（4种范围决定了N）

前面讲过的全文索引只附一张图：

<img src="C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114214650019.png" alt="image-20250114214650019" style="zoom:67%;" />

### 多列索引

最多再16列上创建索引，是按照靠前靠左的方式查询的，不能搞反了。（最左索引）

<img src="C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114214857175.png" alt="image-20250114214857175" style="zoom:67%;" />

索引可以有升序降序：不同列的升降属于不同的索引

## 数据库结构

目标：最小化IO；相关联的项在一起；是否分表分区

### 数据存储尺寸

- 数据库的列：使用比较小的数据类型，尽量设置为不为空；
- 行格式：REDUNDANT < COMPACT  DYNAMIC  COMPRESSED（把前几位一样的落盘时压缩/存浮动）
- 索引：主键越短越好，基于整数递增（8）/UUID（16）;UUID是生成策略简单，但是不好索引。
- join操作：字段信息应该完全一样两个表里面的booid名字数据类型必须一样，速度会快很多。
- 范式化Normaization：消除冗余数据，但是不能范式化程度太高，否则会效率低下

### 数据类型

- 数值型：字符串（浪费）   or   数值（省空间）学号用数值型：快省空间，避免解析字符串的时间
- 字符型：使用相同的数据集（UTF-8或者Unicode）varchar（尺寸小于8k）BlOB（大于8k，只存一个指针）
- BLOB字段：把很长的东西放到另外的地方只是load进很多指针，效率高不少

### 表的数目

打开一个表会放到一个缓存里面，使用多版本的并发MVCC，每个并发里面都会开一个表（靠log统一）

MySQL对于数据库的数量无限制，对于表也无上限；由操作系统对文件系统的上限决定

表的尺寸：也由操作系统对文件系统的上限决定。最多4096列，行的尺寸：一行最多64kb（65535），varchar，TEXT和BLOB（基本可以的）varchar除了写出来的大小，还需要有1-2个bit存储到底放了几个，所以不可以varchar（65535）。char不能大于页面的一半大小。

<img src="C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114223717045.png" alt="image-20250114223717045" style="zoom:40%;" /> <img src="C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114223736004.png" alt="image-20250114223736004" style="zoom:50%;" /> 

![image-20250114223817550](C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114223817550.png)

![image-20250114223842480](C:\Users\77043\AppData\Roaming\Typora\typora-user-images\image-20250114223842480.png)