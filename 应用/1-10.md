# 应用体系架构（大三上）SE十二童首1-10

# 1-Architecture && service component

- 应用服务器和数据库服务器分开：数据库服务器架在内网 外网连不到
  - 性能：
  - 安全：数据库不能用应用ip访问
- 分布式缓存服务器
  - 读盘慢
  - 注意经常变化的不要放到缓存里，保证一致性
- 负载均衡服务器：调度多个应用服务器
  - 可能要求同一个session调用同一个服务器（nginx中的ip hash）
- 数据库主从备份
  - 写主 同步从；读 主从均可 负载均衡
  - 可能切换主从角色，防止过热过冷
- CDN内容分发网络
  - 内容放到全国各地，访问的时候距离最近
  - 反向代理服务器：访问的时候 反向代理服务器去管具体访问哪个节点
- 统一数据访问网关
  - 抽离先缓存，后数据库等，访问数据统一走数据访问网关
- 多数据库
  - 数据放在最适合的地方，数据访问网关统一管理
- 消息服务器
  - 异步通信
- 微服务
  - 公共服务复用

一个完整的企业级应用架构图如下：

![1736606977636](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736606977636.jpg)



## 实例

### 实例池，对象**池**

- **管理和重用对象实例：**对象池通常是一个集合，用于存储和管理多个对象实例。当需要使用对象时，可以从对象池中获取一个可用的对象，而不是每次都创建新的对象。一旦使用完成，可以将对象返回到对象池中，以便稍后重用，而不是立即销毁它。
- 有一定的大小：防止1000条访问内存爆炸
- 一定的内存大小服务多个用户：
  - 如果只能写两个，共有ABC三个状态
  - 写入A，B后，C也要进入
  - 就把A序列化成字符串后把C swap in，把A swap out到磁盘上
  - swap in/out的根据是LRU
  - 有状态的因为swap in/out太多，所以效率低还占据空间，所以最好写无状态代码



### HTTP状态

#### Http是无状态协议：

每次HTTP请求都是独立的，服务器不会自动记住前后请求之间的关系。每个请求在服务器看来是一个完全独立的事务，与之前的请求无关。（如果你发出多个请求，服务器不会跟踪这些请求之间的顺序或关系）



#### **HTTP有状态服务：**

1. Session：存储在服务器端，服务器为每个用户会话生成一个唯一的Session ID，用键值对存储信息（信息可以比较复杂）
   - 某一个用户的购物车对象等信息
2. Cookie：存储在客户端（浏览器），安全性低
   - cookie对应的是每个对象的id
3. Token：存储在客户端（浏览器的LocalStorage、SessionStorage或Cookie中），包含了用户的身份和权限信息，服务器不需要保存Token状态。加密数据片段，通常用于身份验证。Token 常见的形式是JWT（JSON Web Token）

有状态**消耗额外的（内存）资源**



#### 无状态服务

- 上一次调用跟这次没关系，尽量无状态
- 只要一个对象都行



### Scope

- Singleton（单例模式） : Stateless

  - 默认，整个bean里只有一个对象
- Prototype : Stateful

  - 每次**调用(所有的Bean)**产生一个新对象
  - 所以两次访问会产生两个controller（如果controller为prototype）
- request 专用于web应用

  - 每次http请求就产生一个新对象
- session 专用于web应用

  - 一个客户端调用两次，使用的是一个对象

  - 两个客户端各调用一次，使用的是两个对象（会属于不同的session）
- application 专用于web应用

  - 整个bean只有一个对象



#### 应该如何设计scopes of Beans

- 如果不同用户看到的内容一样，使用singleton即可
  - 比如主页的所有书籍的具体信息
- 如果不同用户看到的内容不一样，即需要为每个用户维护一个状态，就可以用prototype
  - 让每个用户维护它在线多长时间了
    - 这个东西就可能需要做一个session和prototype的组合

------



#### 连接池

- 连接本质是线程，线程切换有代价

- 数据库连接池和实际能够承受的连接数的关系：

  connections =((core_count * 2) + effective_spindle_count(有效硬盘数量))

  - 数据库的最终实现是读硬盘，但是在读的时候线程是废的，所以还要加上有效的硬盘数量
  - 这个硬盘数量指的是数据库硬盘的数量，而不是后端服务器硬盘的数量

- 读盘过程线程是空的，可以通过线程切换再加用户

  - 但是最多就开core_count*2个线程

- 用户多就开大是错误的：线程切换太大，不要有太多连接；

- **连接池大小和用户数前端 没关系（不要开多连接数**

  - 上面的公式中连接数已经是数据库效率最高的方式





------

# 2-异步通信 JMS

#### 为什么要异步通信

同步通信的缺点：

- 紧耦合：没有变化保障
- 没有送达保障：过多 / 挂了（通信不可靠的时候） 都调不出来
- 软件物种化：
- 没有请求缓冲：太忙了直接失败
- 过于强调请求和响应（Too Much Emphasis on Requests and Responses）
- 通信不可重放（Communication is not Replayable）

#### 异步模型

没有客户端和服务器的区分，client和server都和kafka cluster这个中间件交互（kafka就是帮助异步通信的中间件）

发信息，发完后可能没有及时响应，但之后一定会完成；发完消息后不用等待

- 后端异步（甚至是不同层之间都可以）：
  - 防止请求过多 丢失；请求放到消息队列，服务什么时候有空了就去处理
- 异步通信的优点（其实同步通信的缺点就是异步的优点）：
  - 不会产生因为service忙而请求被丢失的问题
  - 很好地利用了空闲时间和空闲资源

#### topic 消息缓冲区（消息队列）

- producer发送消息到队列topic中（string
- consumer不断从topic中拿string并解析成对象

#### client如何知道处理完成

1. **client 发ajax获取：轮询机制查询**，无需中间件比较灵活，但严重增加服务器负载，造成不必要的带宽浪费

2. **websocket：**实时更新，双向工作，节省了带宽通信量，可以保持持久连接；保持连接讲持续占用服务器资源，老浏览器不兼容

3. **服务器把结果推到另一个topic**，client监听该消息队列，发现非空后就将内容取出得到结果：

   - 直接交互，不需要单独写新接口（都运行kafka监听）；复杂，客户端直接与Topic连接，**Topic直接暴露**，需要确保消息传递的安全性


#### 完整详细过程：

1. 前端发起的请求会发到中间件的某个topic（假设为topic A）里面。**此时后端会直接给前端发回一个ok响应，并在后续的步骤异步处理请求**
2. 一旦服务器接口空下来，它就会去扫描对应topic（topic A）看看里面有没有请求，一旦有就将消息取出，转换成json格式，然后进行处理。
3. 同时服务器处理完请求后，会将结果存入另一个topic（假设为topic B）
4. client也会在空闲后扫描topic B，发现非空后就将内容取出得到结果
5. 即service会监听topic A，client会监听topic B

### 应用场景

- **有忙有闲，闲的时候处理忙的时候的缓存请求**

  - **一直忙：增加机器**

  ![1736608390063](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736608390063.jpg)

- 上图中：就是在请求密度很高的时候，仍旧较为平稳地处理请求（虽然我也看不太懂画的啥玩意）

- 问题：client如何知道结果是否成功



## JMS Java Message Service

- 消息传递异步

- 通过异步达到高可靠性：发完消息，不管consumer在不在线，都会先缓存，直到在线了再发；不会发完直接失败

- 客户端

- 消息中间件，消息触发

#### JMS API 特性

- 允许Application clients（本来的发请求、处理请求的都算这种）
- 规定了Message send and receive operations

#### message格式

message的格式是弹性的，包含以下三个部分：

- A header
- Properties（可选的）消息属性，是对消息头的补充
- A body（可选的）消息体
- 消息可以没有消息体、属性，但是一定有消息头

- 怎么发消息

  - 消息转化为纯文本：特定格式 （header + *properties + *body）

    - 消息模式：可能发不到就不发了：对时间顺序敏感：先2后1有问题(time stamp 属性)，晚发的消息1会被忽视

      ![1736651438701](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736651438701.jpg)

  - 扩展规则：可用来指定接收者等等

    ![1736651507874](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736651507874.jpg)

    - Property name
      - 即使在同一个topic下，也可以通过name对于收到该信息的service做区分（select）
      - 比如所有班级的家长都往一个邮箱里寄信，两封信中的name起为A和B，那A和B学生就能拿到对应的正确的信（虽然在一个邮箱里）
    - Property value


JMS的消息体类型

JMS的消息体类型：

- TextMessage：转成String类型就可以存
- MapMessage：就是Java的Map类
- BytesMessage：字节数组
- StreamMessage：任意一个流（必须是基础类型的）
- ObjectMessage：对象一定要能够被对象化
- Message：body为空，是上面五类的父类对象
  - 当你不知道传过来的Message是什么类型的时候就用这个

![1736651705682](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736651705682.jpg)

#### JMS API Architecture

![image-20240929213456517](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20240929213456517.png)

- Destination(D)分为两种
  - topic
  - queue
- JMS Client（收发消息的都算client）
  - 先通过连接工厂找到一个到JMS的连接，才能够进行收发消息
  - Messaging Styles 有两种
    - 发送消息的模式是ptp（point-to-point）
      - 如果client1发送的消息2接收到，3不会受到消息
    - publish/subscribe 广播模式
      - 每个message可以有多个consumer

#### JMS消息传输模型

1. **点对点（Point-to-Point，P2P）模型**：

- 在这个模型中，消息生产者发送消息到队列（Queue），消息消费者从队列中接收消息。
- 每个消息只能被一个消费者接收，一旦消息被消费，它就会从队列中移除，确保消息不会重复处理。
- 这种模型**适用于需要确保消息只被处理一次的场景**，例如订单处理、用户请求处理等。

![1736651840924](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736651840924.jpg)

2. **发布/订阅（Publish/Subscribe，Pub/Sub）模型**：

- 在发布/订阅模型中，消息生产者（发布者）将消息发送到**主题（Topic）**，而消息消费者（订阅者）订阅感兴趣的主题。
- 一个发布者发送的消息可以被多个订阅者接收，这使得发布/订阅模型**非常适合需要一对多通信的场景**。
- 订阅者可以设置过滤条件，只接收满足特定条件的消息，这增加了消息传输的灵活性。

![1736651959817](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736651959817.jpg)

两种模型的特点对比：

- **一对一 vs 一对多：**
  - P2P模型是一对一的消息传输，每条消息只有一个消费者。
  - Pub/Sub模型是一对多的消息传输，一条消息可以被多个订阅者接收。

- **队列 vs 主题：**
  - 在P2P模型中，使用队列作为消息的容器，队列**保证了消息的顺序性和独立性。**
  - 在Pub/Sub模型中，使用主题作为消息的发布点，主题允许多个订阅者接收消息。

- **消息确认：**
  - 在P2P模型中，消费者通常需要显式确认消息，告知消息服务器消息已被成功处理。
  - 在Pub/Sub模型中，订阅者可能需要确认消息，也可能不需要，这取决于具体的实现和配置。

- **消息持久性：**
  - 在两种模型中，都可以配置消息的持久性，确保消息不会因为系统故障而丢失。

JMS的这两种消息传输模型为不同的应用场景提供了灵活的消息传递机制，允许开发者根据业务需求选择合适的模型来实现消息通信。

![1736652058797](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736652058797.jpg)



### 异步通信 - kafka

- 消息中间件
- **发布/订阅模式**，存储转发
- 基于日志实现：append-only只追加：在后面不断更新
  - 顺序写：速度快
- 对不同用户维护不同用户读的index
  - 不同用户按自己的进度读 不会读乱
  - 当一个消息被所有的消费者读走了之后，这个消息 才会被删除掉；多个用户可以读取同一个log，并且维护他们各自的文件位置（都到哪里了）这样就能保证log文件不可能无限制的增长
- 如果一个topic放相同的对象：每个对象长度相同，通过偏移量快速定位
  - 种类多，topic多
- 如果一个topic记录多种类型：每个都要记录起始位置和长度

#### 分区

- 加快处理，逻辑自己指定
- 不同用户处理不同的区
- 对于集群的容灾：用空间换可靠
  - 比如每个数据存储两个副本，这样比如有一个卡夫卡服务器崩溃了，还有一个**备份**能够使用。
- 检测死没死：**心跳**：
  - 此时就需要一个协调器在kafka集群里面，consumer一直发心跳包给协调器，如果不发协调器就不会再把消息给故障的机器。





------

# 3-websocket

- **全双工**（双向都工作）通信，request端和response端完全对等，即用户可以主动给服务器发消息，服务器也可以主动给用户传递消息。底层使用TCP协议（安全保证）
- 服务器发布（publish）一个 WebSocket 端点**endpoint**，客户端使用端点的**URI**连接到服务器。

WebSocket分为两部分：**握手（handshake）和数据传输（data transfer）**



#### 握手（handshake）

1. **客户端发起 WebSocket 握手请求：**客户端通过使用其URI向WebSocket端点发送请求来启动握手。握手（handshake）与现有的基于HTTP的基础设施兼容，Web服务器解释其为HTTP连接升级请求
2. **服务器响应 WebSocket 握手请求**
3. 客户端收到服务器的响应后，验证 `Sec-WebSocket-Accept` 是否正确。如果验证通过，服务器和客户端就可以互相发送消息了

**Sec-WebSocket-Accept 的生成：**

- 服务器对Sec-WebSocket-Key标头的值应用已知操作，以生成Sec-WebSocket-Accept标头的值。
- 客户端对Sec-WebSocket-Key标头的值应用相同的操作，如果结果与从服务器接收到的值匹配，则连接成功建立



#### 如何创建并部署一个endpoint：

1. 创建端点类（endpoint）
2. 实现端点的生命周期方法（发送、接受信息的时候要做些什么事情）
3. 将您的业务逻辑添加到端
4. 在web应用程序内部部署端点

开发中一般使用annotation的方法实现endpoint



#### 一些WebSocket的生命周期方法：

![image-20241009085143942](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20241009085143942.png)

- OnOpen：建立连接的时候要做什么
  - 封装好session并写入list，这个list在发消息的时候会遍历这个list
- OnMessage：收到消息的时候
- OnError
- OnClose

#### 维护session list

创建端点的的时候也会为它建立一个session list并维护（将所有的session按顺序放进去）

- 连接后是通过session发消息
  - send的时候就会需要拿到每个session并将消息广播出去（也可以指定具体的接收者）

- sessionlist要求是线程安全的（可能多线程）
  - 如果不是线程安全的可能会导致数据丢失甚至崩溃

#### 编码器 解码器

发消息的时候使用

- 可以增加编码器和解码器
- 将对象decode成方便发送的格式

#### 通信机制共存

![1736653099137](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736653099137.jpg)



# 4-transaction 事务

只有100张票的东西却有200个人同时并发在抢，如何控制不会出错，确保数据库中的状态是一致的

- 不会因为并发请求同时处理使得数据库的数量出问题

如何确保两个操作是原子性的？（即要么都发生要么都不发生）

需要使用java中的transaction

- 要么全部执行
- 如果部分执行则要对执行了的部分进行回滚

#### Java Transaction Api（JPA）

- 支持声明式的事务控制
- **begin transaction，先扣钱、再存钱、再更新操作日志，commit transaction**
  - 原子性问题，上述即为达到transaction的伪代码

#### 事务的定义：

一系列必须全部成功完成的操作，要么都执行，要么都不执行（事务回滚）

#### 显式使用transaction的不同方法

没有显式使用transaction之前，bean都是用container管理的

- 比如methodA要调用methodB
- 进入methodA，该线程就会依附上一个事务TX1
  - TX1肯定要在methodA执行完毕后才会尝试提交/回滚
- 调用methodB时，该线程会进入哪个事务执行呢？
  - 这就由下面的不同状态来定义

#### 六种@TransactionAttribute的状态：

methodA中调用methodB

- Required
  - 在方法前面加注解@TransactionAttribute(REQUIRES)
    - 也可以在整个bean上面加
  - 有加入，没有新建
  - 在调用methodB（B也为Required）的时候，会将methodB加入到调用它的方法的事务，即methodB执行的时候也在事务TX1中
    - methodB执行结束后，TX1会检查是否能提交/回滚，但是因为是A创建的所以不能
    - 返回到methodA结束后，TX1才能最终选择提交/回滚
  - 适用于绝大多数情况，**确保所有相关操作要么一起提交，要么一起回滚**
- RequiresNew
  - method B会开一个新的TX2，method B执行结束之后就会执行一次提交/回滚，成功与否不影响A
  - 新建一个事务，原有事务被暂时挂起
  - 用于需要方法独立执行、避免与外部事务干扰的情况
  - 若A中有方法B，若A为Required，B为RequiresNew,那么B发生错误不会影响A
    - 比如上述问题，不希望log操作失败就将扣钱、存钱也进行回滚，所以将log声明为RequiredNew。
- Supports
  - B在A的中执行状态下执行
  - 即无论A有没有事务，B都和A在相同的事务/没有事务的背景下执行
  - 用于可选择性的事务操作，事务性并不是必需的
- NotSupported
  - None，当前方法不支持事务。如果调用时有事务存在，事务会被挂起，方法执行完成后再恢复原来的事务；挂起现有事务，无事务支持
  - 如果B为NotSupported，则调用B时会先将A的TX1挂起，然后在非事务的状态下执行B，再回到A进行执行
  - 当不希望方法在事务上下文中运行时，比如不需要事务保证的一些只读操作
- Mandatory
  - 如果A有事务就加入，如果A没有事务就抛出异常
  - 强制要求方法必须在事务中执行
- Never
  - 和Mandatory恰好相反，在事务里抛出异常，不在事务里则正常执行（也不会创建事务）
  - 需要确保方法绝对不在事务中执行时

![image-20241009082354142](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20241009082354142.png)

![1736653548289](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736653548289.jpg)



#### 事务四个属性：ACID

- a：atomic原子性（可以使用双required确保整个事务回滚）
  - 不可分割性，事务单元全部成功或者全部失败
- c：consistency 一致性
  - 一个正确（一致）的状态转移到另一个正确的状态
  - 比如银行存款无论怎么扣都要确保值不能是负的

- i：isolation 隔离性，互不干扰
  - 多个事务在并发执行的过程中所得到的结果，和串行执行得到的结果一致
  - 解决A和B做并发操作时，做到不会卖重复
- d：durable 持久性
  - 永久保持，执行结果不会丢失（数据库要保证提交的东西绝对不会丢失）
    - 通过undo log和redo log来确保
  - 只要正常提交，数据库中的数据变化就一定长久可见



#### Isolation

事务隔离级别控制的是**同一时间内多个事务如何相互影响数据可见性**的问题。

#### 隔离性冲突总结

| **写读冲突** | **脏读**       | 事务A读取了事务B修改但未提交的数据（读到了事物处理的**中间状态**），事务B随后回滚，导致A读的数据无效。（解决：不能读中间状态 |
| ------------ | -------------- | ------------------------------------------------------------ |
| **写读冲突** | **不可重复读** | 事务A第一次读取数据后，事务B修改并提交该数据，事务A再次读取时数据被修改。（解决：读了就锁 |
| **读写冲突** | **幻读**       | 事务A执行范围查询后，事务B插入/删除了满足条件的记录(但B还没确定)，事务A再次查询时不同。（解决：将整个table锁住 |
| **写写冲突** | **脏写**       | 事务A和事务B同时修改同一条记录，事务B的提交覆盖了事务A的修改。 |

- 写读冲突的例子：
  - 事务A：小明账户存款100元
  - 事务B：家长查询小明存款
  - 如果事务A、B并发执行就会导致dirty read脏读
    - 比如如果B读取到了A的中间状态，因为不知道A最终会提交还是回滚，此时B读到的数据就可能是错误的
- 不可重复读的例子：
  - 两个人抢同一张票，一个人先读到了还有一张，然后进行购买流程。另一个人在前一个人进行购买流程的时候也读到了还有一张，但是准备买的时候前一个人下单成功，导致读到有票，可是要买的时候票没了。
- 幻读：如果表里插入了新数据，且满足query的条件，查询时不断会有满足条件的新数据出现



#### **Read Uncommitted：**

- **特性**：允许一个事务**读取另一个未提交事务的修改**，可能发生**脏读**（Dirty Read）。
- **优点**：并发性能较高；
- **缺点**：最低的隔离级别，可能会看到未提交的数据变化。

#### **Read Committed：**

- **特性**：**只能读取已经提交的事务修改**，避免了脏读，但可能发生**不可重复读**（Non-repeatable Read）。
- **实现原理：**增加写锁
- **优点**：大多数数据库的**默认级别**，保证每次读取的数据都是已提交的；
- **缺点**：同一事务中，连续读取同一条数据可能会不一致。

#### **Repeatable Read：**

- **特性**：**保证同一个事务中多次读取的数据是一致的**，解决不可重复读的问题，但可能会发生**幻读**（Phantom Read）
- 实现原理：增加读锁。
- **优点**：确保读取的记录在事务期间不发生变化；
- **缺点**：仍可能有幻读问题（即插入新数据时的并发问题）。
- **解释**：与不可重复读的区别在于，**不可重复读**是针对**已存在的记录**的修改，而**幻读**则是因为**并发事务插入或删除了新的记录**，从而影响了查询结果集的条目数量或内容。对一个同一个List在同一事物读取，第一次读到10个，第二次读到11个，因为中间插入了一个数据。

#### **Serializable：**

- **特性**：**最高级别的隔离，事务之间完全隔离**，仿佛事务是一个接一个顺序执行的，解决了幻读问题。
- **优点**：提供了最高的事务一致性；
- **缺点**：没有任何并发，完全时串行的操作
- 所以很少使用，因为性能实在太差

SQL：JDBC的连接是什么属性，是在数据库里设置的

![image-20241009084631321](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20241009084631321.png)







------

# 5-多数据库 分布式事务

#### 两阶段提交协议

![1736657541612](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736657541612.jpg)

- 两阶段：
  - 第一阶段prepare
  - 第二阶段commit
- 启发式：网断了，不知道manager的决定，从提交/回滚中猜一个
- 但是无法避免第二阶段的启发性错误



#### 并发锁

- 乐观离线锁 optimistic offline lock（认为读多写少
  - 离线：从数据库拿走之后自己玩
  - 在会话提交更改之前，会进行冲突检测。如果检测到冲突，则会话无法提交更改
  - 加版本号version int
  - 写的时候和读的时候版本号不一样，冲突
  - 这玩意就是cse里面那个乐观多版本锁机制
- 悲观 Pessimistic Offline Lock （认为写多
  - 读了就锁
  - 浏览次数（更改很多的情况
- **粗粒度锁** Coarse-Grained Lock
  - 锁多张表（一个锁）
    - 乐观锁：共享version，写的时候检测version
    - 悲观锁：统一一个锁锁版本号对象， 读就锁

事务在资源管理器来管的，不会管内存，需要维护过这个对象之前的状态；是在对事务性的对象做



## 数据库事务管理 log

### 调度

为了更好解释并发控制过程中，数据库对事务的处理流程而引入的

定义：事务并发过程中，决定事务中每个操作的执行顺序

- eg:小明要扣款100元，分为三步
  - 读取小明余额
  - 计算扣款情况
  - 将扣款后金额存回数据库

假如有两个事务，T1为消费100元，T2为消费200元

- 若**串行调度**，慢但是正确
- **并行调度**快，但是可能会出现错误的情况



#### 调度定义下的并发控制：

- 给定一个并发调度S'，存在一个串行调度S，在任何数据库状态下，按照S和S'执行后产生的结果都是相同的。
- 此时调度S'被称为**可串行化调度**



#### 可串行化调度

- 数量十分巨大，且难以校验
- 数据库中一般通过找到可串行化调度的子集（充分条件），即找到能提前确认为可串行调度的并发调度
  - 即找出来一个能用的就行，不用找出所有的然后选最优
  - 找的方式：冲突可串行化调度
- **操作交换：**定义为交换事务调度序列中相邻的两个操作，一次交换操作可以将一个调度A变为另一个调度B
  - 当交换不会影响两个调度的一致性，则称该交换得到的两个调度是等价的，该交换为等价交换
    - 等价操作：交换连续两个相同数据读取操作的顺序
    - 等价操作：交换连续两个不同数据读写操作的顺序
    - 非等价操作：交换连续两个相同数据读写操作的顺序
- 如果一个并发调度可以通过等价交换变为一个串行调度，则认为该并发调度是安全的
- 但如果使用不等价交换就可能出现冲突



#### 冲突可串行化调度

- 定义：从冲突的角度出发，针对一个调度S（可能存在冲突）去发现其等价的串行调度S'来确定S是一个可串行化调度

  - 是一种特殊的确定是否是可串行化调度的方法

- **验证是否冲突可串行化**：（对同一数据的冲突连线

  ![1736658407308](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736658407308.jpg)

  - 要求为优先图（无环，有环就非冲突可串行化

  ![1736658500316](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736658500316.jpg)

##### 结论：如果调度S‘中T~i~,T~j~的某两个操作存在冲突，且T~i~的冲突操作在T~j~之前。若调度S'存在冲突等价的串行调度S，则在串行调度S中T~i~一定在T~j~前面



### 事务原子性和持久性的实现

#### 原子性

- 事务运行期间不刷盘，故障系统重启后自动保证原子性
  - 优点：在事务提交前绝对不会写到硬盘中，使得回滚特别方便
  - 缺点：事务中处理的事情如果多，会占据很多空间
- 事务运行期间刷盘，故障系统重启需回滚该事务
  - 优点：内存占用小
  - 缺点：如果遇到故障重启，恢复事务需要进入硬盘进行回滚，比较麻烦

#### 持久性

- 事务完成（commit/abort）时刷盘（即一完成立刻刷盘），自动保持持久性，磁盘IO次数多——undo
- 事务完成时不刷盘（可能等到脏页写到一定数量后统一刷盘），故障系统重启后需重做该事务，磁盘IO使用少——redo



#### 数据库故障类别：

![1736658703835](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736658703835.jpg)

1. 事务故障
   - 资源冲突或死锁等原因导致失败
   - 只会影响原子性
2. 系统崩溃
   - 数据库自身或操作系统故障
   - 可能会影响持久性
3. 磁盘故障
4. 自然灾害

后两种显然无法避免损失



#### 数据库恢复机制架构

![1736658810193](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736658810193.jpg)

1. 无故障事务回滚（例如余额小于0）
   - 影响原子性，撤掉该事务已做操作
2. 故障事务回滚（如死锁杀死事故）
   - 影响原子性，撤掉该事务已做操作
3. 系统故障（如重启）：丢失内存数据，影响原子性、持久性
   - 原子性：**撤销**未结束（不带commit，abort标记）的事务
   - 持久性：**重做**已经结束（带commit或abort标记）的事务
4. 系统崩溃不能重启：不能提供服务，影响持久性
   - **一主多备**：主备之间通过日志保持一致性，发生故障后切换到其他系统
5. 磁盘故障：影响持久性
   - 磁盘数据多副本；数据备份机制：数据备份，日志备份
6. 自然灾害：
   - 异地多机容灾



#### 系统崩溃恢复

- **脏页：**内存页面已更新，磁盘页面未更新
- **刷脏：**将内存脏页刷到磁盘
- 如果事务在崩溃时刻前已经提交
  - 若未刷脏，则影响持久性，需重做——redo
  - 若已刷脏，则不影响持久性
- 若崩溃时刻前已经中止（abort且已经完成回滚）
  - 如果期间刷过脏，但abort时未刷脏，则影响持久性，需重做（事务部分操作已经落入磁盘，且abort操作未将磁盘中回滚）——redo
  - 如果已刷脏，则不影响持久性
- 若崩溃时刻前未结束
  - 如果已刷脏，影响原子性，需要回滚——undo
  - 如果未刷脏，不影响原子性

汇总：一般情况下，完成未刷脏重做redo；刷脏未完成回滚undo

![1736658915606](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736658915606.jpg)



#### 崩溃恢复策略设计：

- 原子性保证（这个开关在mysql里是可以打开的）
  - 选择：NO-STEAL(非窃取)
    - 未结束事务不能刷脏，不存在原子性问题
    - 占用内存大
  - 选择：STEAL(窃取)
    - 未结束事务可刷脏，影响原子性，需要undo
    - 占用内存小
- 持久性保证
  - 选择：Force（强制）
    - 已完成事务**强制立刻刷脏**，不存在持久性问题
    - IO frequency高，性能差
  - 选择：NO-Froce（非强制）
    - 已完成事务**不强制刷脏**，影响持久性，需要重做
    - IO frequency低，但是影响持久性

![image-20241018134408570](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20241018134408570.png)

维持原子性：undo日志

维持持久性：redo日志



#### 数据页面写回磁盘时机

- 数据库同步写内存数据页，但**异步写回磁盘**
- 刷脏时机（一般不会选择事务完成立刻刷脏，而是如下策略）：
  - 数据库关闭时，所有脏页写回
  - 缓冲区中数据也已满，将被替换脏页写回
  - 数据库设置单独线程定时刷脏
    - 比如进行了1000次写操作后刷脏一次
- 难点：遇到故障如何靠日志回滚



#### 日志

日志是log record的序列，记录了数据的更新，和数据库事务开始/结束的逻辑

日志是磁盘文件

- 日志文件写入后不可修改，即顺序写入，几乎没有随机访问的需求
- 所有日志内容可以顺序写入，提供了高效的写入速度，不影响对数据库的操作性能
- 如果日志太大了会进行截断

日志的分类

- redo log：重做已提交事务的修改，确保数据**持久性**
- undo log：回滚未提交事务的修改，确保数据**一致性**



#### Undo回滚日志

- 格式：<T,X,V~old~>
  - T：事务的唯一标识符
  - X：数据项
  - V~old~：数据项修改以前的值（**记录的是操作前的旧值**）
- 产生时机：当数据T修改数据项X时产生（先日志后执行）
- 作用：实现事务回滚
- 注：一般还包括一个日志序号LSN
- 使用方式：反向扫描（cse讲过的那个）

![image-20241018142005671](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/image-20241018142005671.png)



#### Redo重做日志

- 格式：<T,X,V~new~>

  - T：事务的唯一标识符

  - X：数据项

  - V~new~：数据项**修改以后**的值（新值）

- 产生时机：当数据T修改数据项X时产生（先日志后执行）
- 作用：实现事务重做
- 使用方式：正向扫描



#### 预写日志 WAL

- 数据库日志需要满足预写日志，即**日志必须比数据更早的写入磁盘**（即先日志后执行）
- 日志写入顺序必须和生成时间一致
- 原子性保证：页面写回磁盘时和事务相关的undo日志需要先写回
- 持久性保证：事务提交的时候，和事务相关的redo日志需要先写回



#### 日志实现方式

- 功能
  - undo日志
  - redo日志
- 按照性质分类
  - 逻辑日志
    - 记录高层抽象的逻辑操作
    - 日志量较小，解析速度慢
  - 物理日志
    - 记录数据库具体物理变化
    - 日志量较大，解析速度快
  - 物理逻辑日志
    - 日志记录中包含了数据页面的物理信息，但页面以内的是以逻辑的形式记录的
    - 日志量中等，速度较快



#### 日志的重要性质

1. **幂等性**：一条日志记录无论执行一次或多次，得到的结果都是一致的
   - **物理日志满足幂等性，逻辑日志不满足**
2. **失败可重做性**：一条日志执行失败后，是否可以重做一次达成恢复目的
   - **物理日志满足，逻辑日志不满足**
     - 比如一个逻辑日志的插入数据页面操作。如果插入页面成功而插入索引失败，不能重做，如果重做会报错
3. **操作可逆性**：你想执行日志记录的操作，可恢复原来状态
   - **物理日志不可逆，逻辑日志可逆**

不同日志的各种信息汇总：

![1736659409024](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736659409024.jpg)

redo日志一定是物理日志

- 逻辑日志不具有可重做性，所以不能用于redo

undo日志可以是逻辑日志可以是物理逻辑日志。所以不具备幂等性

- 物理日志不具有可逆性，所以不能用于undo



### 恢复算法

![1736659558786](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736659558786.jpg)

![1736659570763](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736659570763.jpg)

![1736659578571](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736659578571.jpg)

![1736659621147](C:/Users/77043/Desktop/应用/PPT1-6/new_应用系统体系架构.assets/1736659621147.jpg)

补偿日志：Undo日志的redo日志：每次执行undo日志记录后，数据库需要向日志中写入一条补偿日志记录（compensation log record，CLR），记录撤销的动作

- 目的：undo不是幂等的，防止做多次



### 作业3

1. 如果数据库系统在事务执行过程中不断地将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

事务原子性可能出现问题：在事务完成前程序发生崩溃时，事务全部都不应该落盘，但因为执行过程中不断刷脏，导致一些操作已经落盘了，从而不能保证事务的原子性（要么全部成功要么全部失败）

处理：采用undo log，系统崩溃后，可以通过反向扫描相关的undo日志，执行回滚。

2. 如果数据库系统在事务执行提交后再将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

执行期间不刷盘、事务提交后强制刷盘可能会：事务执行过程中不能刷新磁盘，必须占有较大的缓冲区空间，不利于多个事务的并发执行；每次事务提交都必须刷新脏页，消耗大量IO读写资源

处理：使用STEAL模式，利用Undo日志撤销事务；使用NO-FORCE模式，利用Redo日志重做事务；





------

# 6-multithreading 多线程

- 进程：进程有一个自包含的执行环境；进程间内存隔离，互相访问不了；
  - 进程间通信：RMI / Http，RMI通信方式：类似于Server和Client，用Serializable，流的方式传递
- 线程：线程有时被称为轻量级进程。
  - 进程与线程的关系和区别：
    - 进程和线程都提供了一个执行环境，但创建新线程所需的资源比创建新进程少。
    - 线程存在于进程中——每个进程至少有一个线程；线程共享进程的资源，包括内存和打开的文件。这有助于高效但可能存在问题的沟通。

为什么java虚拟机中只说multithread不说multi-process：

- 因为java虚拟机本身就是一个进程，它不可能支持多进程



#### **创建线程**

- 手动创建一个线程，这个线程执行完就结束了。（人为的管理、控制线程）
- 两种实现方式
  - 实现Runnable这个接口（推荐使用这个，因为Java里面只能继承一个类，但是实 现可以实现多个接口）
    - 这个接口里只有一个run方法，这里面写着线程要做的实现
    - 更推荐用这个
      - 涉及到java中单根继承的问题：任意一个类只能扩展自一个类，**一旦它本身是一个扩展类，它就不能被别人所扩展**
  - 继承Thread类（Java是单根继承，和cpp不一样，所以这种方法不推荐）
    - thread类里有一些方法
      - sleep()
      - interrupted()
        - 用来判断线程是否被中断，返回的是一个bool值
      - interrupt()
        - 用来中断某个线程
      - join()
        - t.join()，表示停止当前线程的执行，直到t这个线程终结



#### **中断与存活函数**

- 中断一个线程，调用Thread.interrupt（）方法，让其抛出InterruptedException异常
- 判断是否存活，调用Thread.interrupted(）

#### **join**

- join方法允许一个线程等待另一个线程的完成。如果t是线程当前正在执行的Thread对象，t.join（）

使当前线程暂停执行，直到t的线程终止。和sleep一样，join依赖于操作系统的时间，设备好理论就快，所以你不应该假设join会等待你指定的时间。也和Sleep类似，join通过发出InterruptedException退出来响应中断。



#### **线程间通信**

线程之间主要通过**共享字段**以及**字段引用的对象**来进行通信。这种通信方式非常高效，但可能会导致两类错误：

- **线程干扰**（Thread Interference）：比如多个线程有些在消费有些在充值
- **内存一致性错误**（Memory Consistency Errors）：可能会因为多个线程同时操作数据库，导致内存一致性错误

The tool needed to prevent these errors is **synchronization：解决竞争问题**



#### Synchronization

有synchronazed标记的所有方法共用**该对象**的锁，一个方法执行完才能执行下一个

- 在 **Java** 中，每个对象都隐含地拥有一个**内在锁**（也称为**监视器锁**
- 调用这些方法之间之前要获得这把锁，必须执行完一个操作，另一个操作才能获得这把锁（对象的内部锁）
- Synchronization是基于java中的intrinsic lock实现的，是一个内部锁，每个对象只有一个锁

即使是调用的这个类的static方法，static方法不是属于对象的，是属于这个类的

- 但是类本身（类也是一个对象）也会有自己的对象锁，所以static synchronized也能起到作用

**同步语句——细粒度的控制：**放在语句前，在语句执行前获得对应对象(可以指定)锁

**可重入的锁： ReentrantLock：一个线程**不能获得一个被其他线程占据的lock；但是它能够**获得一个它已经拥有的锁**：我们有一个类 C ，它有一个Synchronized方法 m ， m 里面调用了另外一个Synchronized方法 n ， n 也在 C 里面；这个时候我们发现按照我们前面的逻辑就蚌埠住了。调用 n 的时候，发现这个对象的锁在 m 手里

- 所以java的synchronized关键字实现的内部锁是一把可重入锁



#### 原子变量

除了 long 和 double 之外，其他的基本类型都是原子的。如果我们想要把一个变量变成 原子变量，只需要在变量定义的前面加一个 volatile 修饰就可以了。



#### **Liveness：多线程碰到的各种问题**

- **死锁**：A线程等待B，B等待A，这样就会陷入死锁的循环
- **饿死** starvation ：A想要访问一个共享资源，但是一直获取不到，就像被饿死了一样。（需要消除那些贪婪的线程，避免一个线程长期贪婪的占用资源；所以tomcat里面用了连接池，避免一个连接长期占用资源）
- **活锁**：活锁是指一个线程对另一个线程的动作做出反应，而如果另一个线程的动作也是对前一个线程动作的反应，那么可能会导致活锁

**解决方式：协调资源**

1. **受保护的块（guarded block）**。 最常见的方式，while(!joy) {}简单的循环，但浪费处理器时间。一般不推荐这么做（没有上下文切换的开销
2. 调用`wait`方法会暂停线程，直到另一个线程发出通知**Object.notifyAll**(通知所有等待该锁的线程，表示某个重要事件已经发生，具体谁抢到锁不一定)



#### **Immutable Objects 不可变对象**

如果一个对象的状态在构造之后**不能更改**，那么该对象被认为是不可变的

**一定要改：创建新对象**

缺点:每次更新都要创建一个新的对象，因此大多数程序员不太愿意使用不可变对象，认为开销比较大。

**程序员常常不愿使用不可变对象**，因为他们担心创建新对象的**成本**，而不是直接在原地更新对象。但对象创建的影响常常被**高估**，因为**垃圾回收**带来的开销减少和**无需编写额外的代码**来保护可变对象不受损坏，且可以通过不可变对象带来的一些效率来**抵消**。

#### Synchronized问题

方法是同步的，但在getRGB和getName 之间 颜色直接被另一个线程改了



#### **高级并发特性**

- `Lock` 对象：`tryLock` 方法在锁不可用时立即退出，或者在超时之前退出（如果指定了超时时间）。`lockInterruptibly` 方法在另一个线程发送中断信号时退出，前提是锁尚未获取。
- `Executors`类提供了线程池管理的实现，避免了手动创建和销毁线程的麻烦；里面有一组线程，要线程就从里面找：
  - fork / join：是一种 `ExecutorService` 的实现，设计用于可以递归拆分为较小任务的工作负载
- **并发集合：**并发集合类（如 `ConcurrentHashMap`：通过采用了分段锁的设计，允许多个读线程并发地访问map，并且允许多个写线程并发修改不同的段。）允许多个线程安全地访问集合，无需手动添加同步块。通过分段锁定技术，实现高效的并发操作，减少了锁竞争
- **原子变量 ：**允许线程安全的变量操作，无需显式使用锁
- **ThreadLocalRandom：**每个线程独立生成随机数的方式，避免了传统 `Random` 类在多线程下的竞争问题。

------

- **虚拟线程：**不跟操作系统线程绑定：轻量级线程，可以减少编写、维护和调试高吞吐量并发应用程序的工作量。更加轻量化，比如在被IO阻塞时，那么就把线程解绑；等IO结束时再绑定线程，但不一定是原先的线程。但对于长时间占用cpu的任务不友好
- 平台线程（Platform Thread）：平台线程是一个围绕操作系统（OS）线程的轻量级封装的Java线程。可用的操作系统线程数量决定了平台线程的数量限制；具有较大的线程栈（存储线程执行状态的内存）以及其他由操作系统管理的资源。







------

# 7-Cache

## Memcache

- 在内存中，是 key-value 存储，key 自己设置，可在内存中直接访问到，从而避免读写硬盘速度过慢等问题。

- 问题：数据库本身也有缓存、springJPA 也有缓存，为啥还要加一个 memcache？

- ![alt text](C:/Users/77043/Desktop/应用/7-8/image-1.png)

- 回答：数据库缓存本身不可控，是根据执行的 SQL 语句来处理 cache，并且在数据库 server 上跑，和应用本身不在一起；而 springJPA 也可能不和 memcache 在一起。

- 所以用 memcache 的好处是，用跨进程而不是跨机器。如果 memcache 本身也要分开，那么可以做一个分布式集群，会远远大于 mysql 的缓存，可以放更多的数据。

- 除了放 mysql 的数据，还可以放 mongodb 的数据，甚至可以放 mongodb 和 mysql 两者合起来的数据，memcache 放的可以不是原始数据，所以会快，不需要二次 join 等操作。

- 逻辑：![alt text](C:/Users/77043/Desktop/应用/7-8/image-2.png)

- ### 缓存设计原则

  - 读写分离：经常读的数据适合放入缓存（如 memory cache），而频繁写的数据则不宜放入缓存。因为缓存的目的是为了提高读取效率，如果数据频繁写入，每次写入后都需要同步更新缓存和硬盘，会增加系统开销，降低缓存的性能优势。
  - 数据分类存储：对于一些包含多种属性的数据对象，应根据属性的读写特性进行拆分存储。例如，将相对静态、不常改变的属性（如书籍的 title、author 等基本信息）和动态变化的属性（如库存数量 stock）分开存储。

- ### Cacheable 注解与缓存逻辑

  - Cacheable 注解的作用：在 repository 层的方法上使用 Cacheable 注解，表示当调用该方法获取数据（如获取 book 对象）时，会将获取到的结果放入缓存中。这样，下次再请求相同的数据时，可以直接从缓存获取，而无需再次执行数据库查询或其他耗时操作，从而提高数据访问效率。
  - 缓存 key 的命名约定：为了在缓存中区分不同类型的对象，通常会为缓存 key 设定一定的命名规则。例如，对于 book 对象，缓存 key 以“books”开头，后面跟上具体的标识符（如 book 的主键）。这样做的好处是可以避免不同对象因主键相同而产生缓存 key 冲突。比如，不同表的主键都可能是整数递增的，通过在 key 前加上表名或对象类型前缀（如“persons”“books”等），可以明确区分不同对象的缓存数据。
  - 缓存逻辑流程：
    - 查询缓存：当调用带有 Cacheable 注解的方法（如 getByISBN 方法）时，首先会到缓存中查找对应的 key（以“books”开头加上 ISBN 值）。如果缓存中存在该 key 对应的数据，则直接返回缓存中的 book 对象。
    - 缓存未命中处理：如果缓存中找不到对应的数据，会执行方法体内的逻辑。例如，故意延迟 3 秒（通过让线程睡眠 3 秒来模拟耗时操作），然后根据传入的 ISBN 创建一个新的 book 对象。
    - 更新缓存：创建完新的 book 对象后，会将其放入缓存中，并且缓存的 key 会按照约定的规则（以“books”开头加上 ISBN 值）进行设置。这样，下次再请求相同 SBN 的 book 时，就可以直接从缓存中快速获取，而无需再次执行创建 book 对象的逻辑。

- ### 内存缓存的高效存储与管理

  - 内存划分与对象存储：
    - 内存划分：内存缓存被划分为多个不同大小的“chunk 内存块”，每个内存块可以存储特定大小范围的对象。例如，有 88 字节、112 字节、144 字节等不同大小的内存块，依次往上可以到更大的内存块。
    - 对象存储策略：当存储一个对象时，会根据对象的大小找到合适的内存块进行存储。如一个 100 字节的 book 对象会存储到 88 - 112 字节范围的内存块中；一个 288 字节的 person 对象会找到大于 288 字节的合适内存块存储。这种按大小划分和存储的方式可以提高内存的使用效率，避免空间浪费。
  - 命名空间与对象定位：
    - 命名空间分类：除了根据对象大小存储外，还会根据对象的类型（如 book、person 等）作为命名空间进行分类。例如，所有 book 对象都会存储在以“book”为命名空间的内存块中。
    - 快速定位对象：在查找对象时，首先根据对象大小快速定位到合适的内存块范围，然后在该范围内通过命名空间进一步精确定位到具体对象。这种组织方式使得内存使用效率高，查找速度快，就像在抽屉里分类放置大小不同的物品，需要时能快速找到。

- ### 分布式缓存的扩展与数据分布

  - 分布式缓存扩展：
    - 服务器数量变化：在分布式缓存系统中，可能会面临服务器数量变化的情况，如从 10 台服务器扩展到 11 台，或者从 10 台减少到 9 台。
    - 数据重新分布问题：如果简单地对服务器数量进行散列（如对 10 台服务器进行散列），当服务器数量发生变化时，所有对象的存储位置都会发生变化，这会导致缓存数据的大量重新分布，影响系统性能和数据一致性。
  - 合理的数据分布策略：
    - 使用 key 散列：一般会使用对象的 key（可以包含命名空间和对象 ID）进行散列，以确定对象在服务器集群中的存储位置。
    - 一致性散列等策略：为了解决服务器数量变化导致的数据重新分布问题，可以采用一致性散列等策略。一致性散列通过在服务器环上进行散列，当服务器数量变化时，只有部分对象的存储位置会发生变化，而不是所有对象，从而减少了数据迁移的开销，保证了分布式缓存系统的稳定性和高效性。
    - ![alt text](C:/Users/77043/Desktop/应用/7-8/image-3.png)

## redis

- ### **Redis 数据类型**

  - ![alt text](C:/Users/77043/Desktop/应用/7-8/image-4.png)
  - 字符串（String）：可以存储字符串或数字。数字是以字符串形式存储的，适用于简单的键值对存储场景，如缓存单个值或对象的序列化字符串。
  - 哈希表（Hash）：存储键值对集合，类似于 Java 中的 Map。适用于存储对象的多个属性，如用户信息（用户名、密码、邮箱等），每个属性是一个键值对，通过对象的 ID 作为哈希表的 key 来访问。
  - 列表（List）：基于链表实现，可以存储多个元素的有序集合。适用于存储具有顺序关系的数据，如消息队列、评论列表等。列表中的元素可以重复。
  - 集合（Set）：存储无序的、不重复的元素集合。适用于存储不需要排序且元素唯一的数据，如用户的兴趣标签集合。
  - 有序集合（ZSet）：每个元素都有一个分数，可以根据分数进行排序。适用于存储带有权重的数据，如排行榜（按分数高低排序的用户列表）。

- ### **Redis 分布式特性**

  - 主从备份：Redis 支持主从备份机制，可以将数据从主节点复制到从节点。这样即使主节点出现故障，可以从从节点恢复数据，提高数据的可靠性和系统的可用性。备份可以在不同的机器上进行，也可以在同一台机器的不同内存空间进行。
  - 分布式缓存：在分布式系统中，Redis 可以部署在多台服务器上，形成一个分布式缓存集群。当集群中的某个节点缓存数据丢失时，可以通过其他节点进行数据恢复，保证缓存数据的一致性和完整性。

- ### **Redis 应用场景**

  - 缓存实体类：可以将应用程序中的实体类（如用户、书籍、商品等）缓存到 Redis 中。通过设置合适的 key（如实体类名称加 ID），可以快速从缓存中获取数据，减少对数据库的访问次数，提高系统性能。
  - 消息队列：Redis 可以作为消息队列使用。通过发布/订阅模式，可以在不同的应用程序组件之间传递消息。例如，一个服务可以向 Redis 发送消息，另一个服务可以监听并接收这些消息，实现异步通信。这种方式不需要依赖其他复杂的消息中间件，简化了系统架构。

- ### **Redis 操作与配置**

  - Spring Data Redis：Spring 提供了 RedisTemplate 类，用于简化 Redis 的操作。通过 RedisTemplate，可以方便地执行各种 Redis 命令，如 get、set、hget、hset 等。在使用时，需要注意将对象序列化为字符串存储到 Redis 中，以及从 Redis 中获取字符串后反序列化为对象。
  - 通用操作与数据访问网关：为了避免为每个实体类编写重复的缓存操作代码，可以设计一个通用的数据访问网关。将实体类类型作为参数传递给网关方法，实现统一的缓存操作逻辑，提高代码的复用性和可维护性。







------

# 8-Full-text Searching

![alt text](C:/Users/77043/Desktop/应用/7-8/image.png)**_（下面是这一坨讲解提取出来的知识点）_**

- ### **_数据存储方案（如书评）_**

  - **固定长度字段（定长字段）存储**
    - 定义：这种方案是将书评以固定长度的字段存储在数据库表中。例如，设定字段长度为 1000 个字符。
    - 优点：在内存中存储整齐。因为每个字段的长度都是固定的，所以数据库在内存中的布局非常规整，方便管理和访问。例如，数据库系统可以很容易地计算出每个字段在内存中的起始位置，就像一个整齐排列的书架，每本书（字段）的厚度都一样，方便查找。
    - 缺点：浪费存储空间。如果书评内容较短，比如只有“很好”两个字，但字段长度设定为 1000 个字符，那么剩下的 998 个字符位置就会被浪费。这就像是一个大房间，只放了一张小桌子，大部分空间都没有被利用。
  - **可变长度字段（变长字段）存储**
    - 定义：使用 VARCHAR 这种可变长度的字段类型来存储书评。可以指定一个上限长度，例如 1000 个字符，但在存储时会根据实际内容的长度来存储，并记录长度和偏移量。
    - 优点：存储紧凑。书评内容会紧密排列存储，不会像固定长度字段那样浪费空间。例如，一个很长的书评后面紧接着一个很短的书评，它们在数据库文件中会紧密相连，就像不同厚度的书紧密地放在书架上，充分利用空间。
    - 缺点：管理相对复杂。数据库需要记录每个字段的长度和偏移量，这就增加了管理的复杂性。就像管理一个不规则排列的书架，需要记住每本书的厚度和位置才能找到它。

- ### **外部存储（如 TEXT 或 BLOB 类型）**

  - 定义：将书评作为一个外部文件存储，数据库表中只存储一个指向该文件的指针。
  - 优点：提高主表的存储效率。因为书评字段只占用一个指针的大小（例如在 64 位机器上是 8 个字节），这样主表可以存储更多的记录。这就像是在一个小盒子里只放一张指向大箱子的标签，小盒子就可以放更多的标签，方便管理更多的大箱子（书评内容）。
  - 缺点：需要额外的读盘操作。当需要读取书评内容时，不仅要读取主表记录，还要通过指针去读取外部文件，这就增加了读取时间。就像要找到一本书的内容，不仅要找到标签，还要根据标签去另一个地方找到书，多了一步操作。

- ### **_关于 SQL LIKE 语句_**

  - 通配符的使用：在 SQL 中，LIKE 操作符常用于模糊查询，配合通配符可以实现多种匹配模式。其中，%通配符代表零个、一个或多个字符，常用于匹配不确定长度的字符串，如 LIKE '%awful%'可匹配包含“awful”子字符串的所有记录。
    \_通配符代表一个字符，用于匹配特定位置的单个字符，如 LIKE '\_o%'可匹配第二个字符为“o”的字符串。
  - 性能问题：使用 LIKE 语句尤其是 LIKE '%value%'这种模式时，会导致数据库进行全表扫描，即需要读取表中的每一条记录来查找包含特定子字符串的记录，这使得查询速度非常慢，尤其是当表中记录数较多时，性能会显著下降。

- ### **_ 关于数据存储与结构化_**

  - **非结构化数据存储的弊端**：将包含关键词的字段（如 Remark）直接作为一个字段存储在数据库表中，属于非结构化存储。这种方式在查询时，无法快速定位包含特定关键词的记录，因为数据库需要逐条读取记录并搜索子字符串，效率低下。
  - **结构化存储方案**：可以将 Remark 中的关键词提取出来，单独存储在一个表中，该表包含 book ID、remark ID、关键词等字段。这样，每一条 Remark 对应多行记录，每行记录表示一个关键词及其相关信息。虽然这种方式在存储上可能会导致表的尺寸较大，尤其是当 Remark 文本较长、包含关键词较多时，但有利于后续的查询操作。

- ### 搜索引擎的工作原理

  - 索引（Indexing）：爬取完网页后，搜索引擎会对网页进行整理，提取关键词，去除重复内容，判断质量等，创建索引。索引分为正向索引和倒排索引两种主要方式。
  - 排名（Ordering）：当用户输入查询词后，搜索引擎会使用预先归纳编排好的索引查找匹配页面，按排名因素排好序，再在搜索结果页面将内容展示给用户。排名因素包括相关性、权威性、时效性、重要性、丰富度和受欢迎程度等。

- ### 排序规则

  - 相似度：衡量用户输入的关键词与文档内容的相似程度。如果关键词是一个短语或句子，相似度的计算会更复杂，通常会考虑关键词在文档中的位置和出现频率。
  - 频率：关键词在文档中出现的次数。出现次数越多，文档的相关性可能越高，因此在排序时会优先考虑。
  - 索引的维护
    **增量式更新**：搜索引擎需要能够增量式地更新索引，而不是每次有新内容时都重新构建整个索引。这样可以提高索引的更新效率，减少资源消耗。

- ### **Lucene**

  - 文档读取
    Lucene 将每篇文档视作一个 Document 对象，每个 Document 包含若干个 Field 对象。例如，一个新闻文章的 Document 对象可能包含标题、正文、日期等 Field。Field 可以配置为不同类型：
    TextField：文本字段，可以分词和索引。
    StringField：不分词的字符串字段，适合唯一标识符。
    StoredField：仅存储，不用于索引（例如文档 ID）。
  - 分析和分词
    在文档被加载为 Document 对象后，Lucene 会通过分析器（Analyzer）将文本内容转换为一系列词元。这一步骤是索引构建的核心环节，因为它将非结构化的文本转化为结构化的数据，方便构建倒排索引。
    - 分词器（Tokenizer）：Lucene 内置了多种分词器，如 StandardAnalyzer、WhitespaceAnalyzer 等，适用于不同的语言和应用场景。
    - 词元过滤（Token Filter）：分词后，Lucene 会通过词元过滤器进一步处理词元，例如去除停用词（“the”、“is”等）或进行词干提取（将“running”变为“run”）。
  - **反向索引（Inverted Index）构建**
    - 反向索引是 Lucene 实现高效全文检索系统的核心数据结构，它将每个词元映射到包含该词元的文档中，并记录词元在文档中的位置等信息，用于快速定位关键词所在的文档。
    - 词典（Term Dictionary）：倒排索引中，每个唯一的词（Term）都会存入词典中。词典用于存储所有被索引的词，并且按字典顺序排列。
    - 倒排表（Posting List）：倒排表记录了包含该词的文档 ID 以及该词在每篇文档中的位置信息。倒排表的存储结构可以显著优化查询速度。

> **正向索引（Forward Index）和反向索引（Inverted Index）** 是两种不同的文本索引技术，用于管理和加速文本数据的检索。它们在搜索引擎和信息检索系统中起着关键作用，并在不同的方面具有不同的优势和用途。
> **1. 正向索引（Forward Index）：**
>
> - 正向索引是一种按文档来组织和存储文本数据的索引方式。每个文档都有一个对应的索引项，这个索引项包含了文档中的所有信息，通常以文档的标识符（如文档 ID）为索引的键。
> - 正向索引适合于需要按文档进行检索的场景，例如在文档管理系统中查找特定文档或根据文档属性进行过滤和排序。
> - 缺点是在处理大量文本数据时，正向索引可能需要大量的存储空间，因为每个文档都需要一个完整的索引项。
>
> **2. 反向索引（Inverted Index）：**
>
> - 反向索引是一种按单词或词组来组织和存储文本数据的索引方式。它**将文本数据中的每个单词或词组与包含它们的文档关联起来**，以及它们在文档中的位置。
> - 反向索引适用于全文搜索和信息检索系统，因为它允许根据关键词快速查找包含这些关键词的文档。这种索引方式在搜索引擎中得到广泛应用。
> - 反向索引通常占用相对较少的存储空间，因为它不需要存储完整的文档内容，只需存储单词或词组的位置信息和文档标识符。
>
> **比较：**
>
> - 正向索引适用于需要按文档检索的应用，例如文档管理系统或内容展示。
> - 反向索引适用于需要**全文搜索和关键词检索的应用**，例如搜索引擎和信息检索系统。
> - 正向索引需要更多的存储空间，但在访问特定文档时速度较快。
> - 反向索引占用较少的存储空间，但在全文搜索和关键词检索时速度更快。
>
> 通常，搜索引擎会结合使用正向索引和反向索引，以满足不同的检索需求，并提供高效的搜索体验。正向索引用于快速获取文档的详细信息，而反向索引用于高效地找到包含查询关键词的文档。

## Core Indexing Classes 核心索引类

- **IndexWriter：**

  - `IndexWriter` 是索引创建和维护的核心类。它负责将文档添加到索引、更新索引、删除文档以及优化索引等操作。`IndexWriter` 是在索引建立和更新过程中的主要接口之一。

- **Directory：**

  - `Directory` 是索引文件的存储和管理抽象。它定义了索引文件的位置和访问方式，可以是基于文件系统的目录，也可以是内存中的数据结构。`Directory` 提供了对索引文件的读写操作，使得索引可以被持久化存储和检索。

- **Analyzer：**

  - `Analyzer` 是文本分析的关键组件。它定义了如何将文本数据分割成单词或词组，进行词干化、去除停用词等文本处理操作。正确选择和配置适当的分析器对于索引的质量和性能至关重要。

- **Document：**

  - `Document` 表示索引中的一个文档。文档通常由一组字段（`Field`）组成，每个字段包含了文档的一部分信息，如标题、正文、作者等。`Document` 用于将文本数据添加到索引。

- **Field：**
  - `Field` 是文档中的一个字段或属性。它包含了字段的名称、值以及用于指定如何处理该字段的配置选项。字段可以是文本、数字、日期等不同类型的数据，根据需要进行索引和检索。

这些核心索引类是构建文本搜索引擎和信息检索系统的基础，它们协同工作以创建、管理和查询索引，以便用户能够高效地检索和获取相关文档。

- ### **查询和搜索**

  查询和搜索过程包括以下步骤：
  解析查询：将用户输入的查询字符串转换成一系列的词元（Term）。
  构建查询对象：使用 QueryParser 或手动构建 Query 对象。
  执行查询：使用 IndexSearcher 执行查询，返回匹配的文档列表。
  结果排序：根据相关性评分对结果进行排序。

- ### **相似度计算**

  Lucene 使用 TF-IDF（Term Frequency-Inverse Document Frequency）算法计算文档的相关性评分。TF-IDF 算法考虑了词频（TF）和逆文档频率（IDF）两个因素：
  TF：词频，表示关键词在文档中出现的次数。
  IDF：逆文档频率，表示关键词在所有文档中出现的频率的倒数。

## Solr 和 Elasticsearch

### Solr

Solr 是基于 Lucene 构建的全文搜索引擎，提供了分布式索引、负载均衡、主从备份等功能。Solr 通过封装 Lucene，简化了索引和搜索的复杂性，适用于大规模数据的全文检索。
Avatar
Lucene 原理及应用

### Elasticsearch

Elasticsearch 是一个基于 Lucene 构建的分布式搜索引擎，支持实时搜索、多租户、高可用性等功能。Elasticsearch 通过分片和副本机制，提高了索引和搜索的性能和可靠性。
例如，Elasticsearch 的基本概念包括：
集群：一个或多个节点的集合，提供跨所有节点的集合索引和搜索功能。
索引：不同类型的文档和文档属性的集合。
类型/映射：共享同一索引中存在的一组公共字段的文档的集合。
文档：以 JSON 格式定义的特定方式的字段集合。
碎片：索引被水平细分为碎片，每个碎片包含文档的所有属性。
副本：Elasticsearch 允许用户创建其索引和分片的副本，提高数据的可用性和搜索性能。







------

# 9-Web Services 

### 总述

- Web Services 提供了跨语言、跨平台的系统集成能力。

- SOAP 和 WSDL 是 Web Services 的核心技术，适合复杂场景。

- RESTful 是一种轻量级的 Web 服务风格，更适合现代 Web 开发。

- 微服务架构继承了 Web Services 的思想，进一步强调服务的独立性和轻量化。

## Web Services 的核心问题

### 跨语言通信

在分布式系统中，不同系统可能由不同编程语言开发（如 Java 和 C#）。Web Services 通过标准化协议（如 SOAP 和 REST）实现跨语言调用，消除语言差异带来的通信障碍。

###  跨地域通信

- 在广域网（WAN）上，数据传输可能受限于网络延迟、带宽和稳定性。
- Web Services 使用基于 HTTP 或其他协议的通信方式，能够在全球范围内传递信息。
- 借助中间件、负载均衡和缓存机制提高远程调用的可靠性。

### 协议多样性

- Web Services 支持多种通信协议，包括：
  - **HTTP**：最常用的协议，适合浏览器到服务器的通信。
  - **SMTP**：通过电子邮件传递消息。
  - **FTP**：用于文件传输。
- 这种灵活性使其适用于各种场景。

## Web Services 的定义

- **Web**：指通过网络协议（HTTP、FTP、SMTP 等）实现通信。
- **Services**：表示服务功能，以标准化的形式（接口）供其他系统调用。
- **目标**：解决分布式系统的集成问题，尤其是跨语言和跨地域的场景。

Web Services 的基本特点包括：

- **松耦合性**：服务的提供方和消费方可以独立开发与维护。
- **标准化**：依赖标准协议（如 SOAP、HTTP、XML、JSON）。
- **可发现性**：服务可以通过 WSDL 或注册中心被自动发现。

## SOAP（Simple Object Access Protocol）

### 定义

SOAP 是一种基于 XML 的协议，用于在分布式系统中进行远程过程调用（RPC）。它提供了一种标准化的消息格式，支持通过多种传输协议（如 HTTP 和 SMTP）传递数据。

### SOAP 消息结构

SOAP 消息是一个 XML 文档，主要包含以下部分：

1. **信封（Envelope）**：
   - 定义消息的边界。
   - 指定消息的头部和主体。
2. **信封头（Header）**（可选）：
   - 包含元信息（如认证信息、安全凭据）。
3. **信封体（Body）**：
   - 包含实际的数据负载（如方法调用的参数和返回值）。

### SOAP 的优缺点

**优点**：

- 跨语言、跨平台，具有高度的互操作性。
- 支持多种协议（如 HTTP、SMTP）。
- 可扩展性强，可添加安全性、事务支持等功能。

**缺点**：

- 消息格式基于 XML，体积较大，解析开销高。
- 传输效率相对较低，不适合对性能要求高的场景。

## WSDL（Web Services Description Language）

### 定义

WSDL 是一种基于 XML 的文档，用于描述 Web Services 的接口、操作、消息格式和访问地址。

### WSDL 文件的结构

1. **Message**：
   - 定义服务中请求和响应的消息格式。
   - 包括消息名称和组成部分。
2. **PortType**：
   - 描述服务的接口（方法）及其输入和输出。
   - 相当于面向对象编程中的类和方法。
3. **Binding**：
   - 定义服务接口与协议的绑定（如 HTTP、SOAP）。
   - 包括协议的细节（如编码方式）。
4. **Service**：
   - 指定服务的访问地址（URL）。
   - 允许客户端定位并调用服务。

### WSDL 的作用

- **客户端**：
  - 自动生成调用代码。
  - 无需了解服务端实现即可调用服务。
- **服务端**：
  - 自动生成服务骨架代码。
  - 确保接口的一致性。

## Web Services 的实现流程

### 服务端实现

1. **定义接口**：编写一个包含业务逻辑的方法（如 Java 接口）。
2. **生成 WSDL 文件**：使用工具（如 Apache CXF 或 JAX-WS）生成 WSDL 文件。
3. **暴露服务**：通过 Web Server（如 Apache Tomcat）发布服务。

### 客户端实现

1. **解析 WSDL**：通过工具生成对应的客户端代码（如代理类）。
2. **调用服务**：通过代理类发送 SOAP 请求。
3. **处理响应**：解析 SOAP 响应消息并提取数据。

## RESTful Web Services

### 定义

REST 是一种基于 HTTP 协议的架构风格，其核心理念是将资源通过 URI 暴露，并通过 HTTP 方法操作资源。

### REST 的核心思想

1. **资源（Resource）**：
   - 每个资源对应一个 URI（如 `/users/123` 表示用户 ID 为 123 的资源）。
2. **HTTP 方法**：
   - **GET**：读取资源。
   - **POST**：创建资源。
   - **PUT**：更新资源。
   - **DELETE**：删除资源。
3. **无状态性**：
   - 服务器不保存客户端状态，每次请求都应包含所有必要的信息。

### RESTful 的优缺点

**优点**：

- 轻量级，基于 JSON 或 XML 格式，传输效率高。
- 易于前后端分离，接口简单清晰。

**缺点**：

- 不支持复杂的事务管理。
- 不如 SOAP 那样标准化，适合轻量级场景。

## Web Services 与微服务的关系

- **Web Services**：是一种用于系统集成的技术，适用于跨语言和跨平台的场景。
- **微服务**：是一种分布式架构风格，强调服务的独立性和轻量级通信。
- **服务注册中心**：微服务架构中常用的组件（如 Eureka、Consul），用于管理服务发现，功能类似于 Web Services 中的 WSDL。

## 安全性问题

### 数据加密

1. **SSL/TLS**：
   - 用于加密通信，防止数据被窃听和篡改。
2. **非对称加密**：
   - 使用公钥加密，私钥解密，确保机密性。
3. **对称加密**：
   - 使用共享密钥加密数据，效率高。

### 身份验证

1. **HTTP 基础认证**：
   - 使用用户名和密码进行验证。
2. **Token 认证**：
   - 客户端通过 OAuth 2.0 或 JWT 获取访问令牌。





------

# 10-微服务

微服务架构通过将系统拆分为多个独立的服务，提高了系统的灵活性和可维护性，但也带来了复杂性和性能开销。在实际应用中，需要结合服务注册与发现、API 网关、消息队列等技术，确保系统的可靠性和可扩展性。

## 微服务的核心概念

### 定义

微服务是一种将单一应用程序拆分为一组小型、独立部署的服务（每个服务运行在自己的进程中）的架构风格。

### 特点

- **独立性**：每个微服务可以独立开发、部署和扩展。
- **语言中立**：不同微服务可以用不同编程语言实现。
- **数据隔离**：每个微服务有自己的数据库或数据存储。
- **轻量级通信**：通常通过 HTTP/REST 或消息队列进行通信。

### 目标

- 提高系统的灵活性和可维护性。
- 支持团队并行开发。
- 提高系统的容错性和可扩展性。

##  微服务与单体架构的对比

### 单体架构

- 所有功能模块集中在一个应用中。
- 开发、部署和维护简单，但随着系统规模增大，复杂性增加。
- 一个模块的故障可能导致整个系统崩溃。

### 微服务架构

- 功能模块拆分为独立的服务。
- 每个服务可以独立部署和扩展。
- 一个服务的故障不会影响其他服务。
- 但通信开销增加，系统复杂性提高。

## 微服务的核心组件

### 服务注册与发现（Service Registry & Discovery）

- **服务注册**：微服务启动时，将自己的信息（如 IP、端口、服务名）注册到注册中心（如 Eureka）。
- **服务发现**：客户端通过注册中心查找服务的位置。
- **动态更新**：服务重启或迁移时，注册中心会更新服务的位置信息。

### API 网关（API Gateway）

- **统一入口**：客户端通过网关访问后端服务。
- **路由转发**：根据请求路径将请求转发到对应的微服务。
- **负载均衡**：支持多个服务实例的负载均衡。
- **安全性**：提供认证、授权等功能。

### 消息队列（Message Queue）

- **用途**：用于异步通信，解耦服务之间的依赖。
- **常见工具**：Kafka、RabbitMQ。

### 配置中心（Configuration Center）

- **功能**：集中管理微服务的配置信息。
- **优势**：支持动态更新配置，无需重启服务。

## 微服务的实现技术

### Spring Cloud

- **Eureka**：服务注册与发现。
- **Zuul/Gateway**：API 网关。
- **Ribbon**：客户端负载均衡。
- **Feign**：声明式的 HTTP 客户端。
- **Hystrix**：服务熔断与降级。

### Docker 和 Kubernetes

- **Docker**：用于容器化微服务。
- **Kubernetes**：用于微服务的编排和管理。

### 消息队列

- Kafka、RabbitMQ 用于异步通信。

### 数据库

- 每个微服务有自己的数据库（如 MySQL、MongoDB）。
- 数据一致性通过分布式事务或最终一致性保证。

## 微服务的通信方式

### 同步通信

- 使用 HTTP/REST 或 gRPC。
- **优点**：简单直接。
- **缺点**：服务之间的耦合性较高，性能可能受影响。

### 异步通信

- 使用消息队列（如 Kafka、RabbitMQ）。
- **优点**：解耦服务，提高系统的响应速度和容错性。
- **缺点**：增加了系统的复杂性。

## 微服务的优缺点

### 优点

- **独立性**：每个服务可以独立开发、部署和扩展。
- **技术多样性**：不同服务可以使用不同的技术栈。
- **容错性**：一个服务的故障不会影响其他服务。
- **可扩展性**：可以根据需求单独扩展某个服务。

### 缺点

- **复杂性**：系统架构和运维复杂度增加。
- **性能开销**：服务之间的通信增加了延迟。
- **数据一致性**：分布式事务管理复杂。
- **调试困难**：跨服务的调试和问题排查难度增加。

## 微服务与缓存（Redis）的结合

### 缓存的作用

- 提高系统的响应速度。
- 减轻数据库的压力。

### 缓存的设计

- **缓存粒度**：缓存单个对象（如一本书）而不是整个查询结果。
- **缓存一致性**：当数据更新时，需要清除或更新缓存。
- **缓存策略**：LRU（最近最少使用）、TTL（过期时间）等。

### 缓存与数据库的协同

- **查询时**：先查缓存，缓存未命中再查数据库。
- **更新时**：先更新数据库，再清除缓存。

##  微服务与无服务器架构（Serverless）

### 无服务器架构

- **核心思想**：开发者只需关注业务逻辑，无需管理服务器。
- **特点**：服务按需运行，按使用量计费。

### 函数即服务（FaaS）

- 将业务逻辑封装为函数，由平台自动调度执行。
- **常见平台**：AWS Lambda、Google Cloud Functions。

### 微服务与 Serverless 的结合

- 微服务可以作为 Serverless 函数运行。
- **优点**：进一步降低运维成本，提高系统的弹性。

## 微服务的监控与日志

### 监控

- **内容**：监控服务的健康状态、性能指标（如 CPU、内存、响应时间）。
- **常见工具**：Prometheus、Grafana。

### 日志

- **需求**：集中管理微服务的日志，便于问题排查。
- **常见工具**：ELK（Elasticsearch、Logstash、Kibana）。

## 微服务的实践建议

### 服务拆分

- 根据业务功能拆分服务，避免过度拆分。

### 数据管理

- 每个服务有自己的数据库，避免直接访问其他服务的数据库。

### 通信方式

- 优先使用异步通信，减少服务之间的耦合。

### 容错与降级

- 使用熔断器（如 Hystrix）防止服务雪崩。

### 自动化运维

- 使用 CI/CD 工具（如 Jenkins）实现自动化部署。

## 课程中的代码示例

### Eureka 服务注册与发现

- 服务启动时注册到 Eureka，客户端通过 Eureka 查找服务。

### API 网关

- 使用 Spring Cloud Gateway 实现请求的路由和转发。

### 函数式服务

- 使用 Spring Cloud Function 实现无状态的服务。

